[{"title":"springboot内置工具类","date":"2022-01-25T05:54:53.000Z","path":"2022/01/25/springboot内置工具类/","text":"断言 断言是一个逻辑判断，用于检查不应该发生的情况 Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数-enableassertions开启 SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查 123456789101112131415161718// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行// 参数 message 参数用于定制异常信息。void notNull(Object object, String message)// 要求参数必须空（Null），否则抛出异常，不予『放行』。// 和 notNull() 方法断言规则相反void isNull(Object object, String message)// 要求参数必须为真（True），否则抛出异常，不予『放行』。void isTrue(boolean expression, String message)// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行void notEmpty(Collection collection, String message)// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行void hasLength(String text, String message)// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行void hasText(String text, String message)// 要求参数是指定类型的实例，否则抛出异常，不予放行void isInstanceOf(Class type, Object obj, String message)// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行void isAssignable(Class superType, Class subType, String message) 对象、数组、集合ObjectUtils 获取对象的基本信息 123456789101112// 获取对象的类名。参数为 null 时，返回字符串：&quot;null&quot; String nullSafeClassName(Object obj)// 参数为 null 时，返回 0int nullSafeHashCode(Object object)// 参数为 null 时，返回字符串：&quot;null&quot;String nullSafeToString(boolean[] array)// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 String getIdentityHexString(Object obj)// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：&quot;&quot; String identityToString(Object obj)// 相当于 toString()方法，但参数为 null 时，返回字符串：&quot;&quot;String getDisplayString(Object obj) 判断工具 1234567891011121314151617// 判断数组是否为空boolean isEmpty(Object[] array)// 判断参数对象是否是数组boolean isArray(Object obj)// 判断数组中是否包含指定元素boolean containsElement(Object[] array, Object element)// 相等，或同为 null时，返回 trueboolean nullSafeEquals(Object o1, Object o2)/*判断参数对象是否为空，判断标准为： Optional: Optional.empty() Array: length == 0CharSequence: length == 0 Collection: Collection.isEmpty() Map: Map.isEmpty() */boolean isEmpty(Object obj) 其他工具方法 1234// 向参数数组的末尾追加新元素，并返回一个新数组&lt;A, O extends A&gt; A[] addObjectToArray(A[] array, O obj)// 原生基础类型数组 --&gt; 包装类数组Object[] toObjectArray(Object source) StringUtils 字符串判断工具 12345678910111213141516// 判断字符串是否为 null，或 &quot;&quot;。注意，包含空白符的字符串为非空boolean isEmpty(Object str)// 判断字符串是否是以指定内容结束。忽略大小写boolean endsWithIgnoreCase(String str, String suffix)// 判断字符串是否已指定内容开头。忽略大小写boolean startsWithIgnoreCase(String str, String prefix) // 是否包含空白符boolean containsWhitespace(String str)// 判断字符串非空且长度不为 0，即，Not Emptyboolean hasLength(CharSequence str)// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blankboolean hasText(CharSequence str)// 判断字符串指定索引处是否包含一个子串。boolean substringMatch(CharSequence str, int index, CharSequence substring)// 计算一个字符串中指定子串的出现次数int countOccurrencesOf(String str, String sub) 字符串操作工具 12345678910111213141516171819202122// 查找并替换指定子串String replace(String inString, String oldPattern, String newPattern)// 去除尾部的特定字符String trimTrailingCharacter(String str, char trailingCharacter) // 去除头部的特定字符String trimLeadingCharacter(String str, char leadingCharacter)// 去除头部的空白符String trimLeadingWhitespace(String str)// 去除头部的空白符String trimTrailingWhitespace(String str)// 去除头部和尾部的空白符String trimWhitespace(String str)// 删除开头、结尾和中间的空白符String trimAllWhitespace(String str)// 删除指定子串String delete(String inString, String pattern)// 删除指定字符（可以是多个）String deleteAny(String inString, String charsToDelete)// 对数组的每一项执行 trim() 方法String[] trimArrayElements(String[] array)// 将 URL 字符串进行解码String uriDecode(String source, Charset charset) 路径相关工具方法 1234567891011121314// 解析路径字符串，优化其中的 “..” String cleanPath(String path)// 解析路径字符串，解析出文件名部分String getFilename(String path)// 解析路径字符串，解析出文件后缀名String getFilenameExtension(String path)// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” boolean pathEquals(String path1, String path2)// 删除文件路径名中的后缀部分String stripFilenameExtension(String path) // 以 “. 作为分隔符，获取其最后一部分String unqualify(String qualifiedName)// 以指定字符作为分隔符，获取其最后一部分String unqualify(String qualifiedName, char separator) CollectionUtils 集合判断工具 123456789101112// 判断 List/Set 是否为空boolean isEmpty(Collection&lt;?&gt; collection)// 判断 Map 是否为空boolean isEmpty(Map&lt;?,?&gt; map)// 判断 List/Set 中是否包含某个对象boolean containsInstance(Collection&lt;?&gt; collection, Object element)// 以迭代器的方式，判断 List/Set 中是否包含某个对象boolean contains(Iterator&lt;?&gt; iterator, Object element)// 判断 List/Set 是否包含某些对象中的任意一个boolean containsAny(Collection&lt;?&gt; source, Collection&lt;?&gt; candidates)// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素boolean hasUniqueObject(Collection&lt;?&gt; collection) 集合操作工具 12345678910111213141516// 将 Array 中的元素都添加到 List/Set 中&lt;E&gt; void mergeArrayIntoCollection(Object array, Collection&lt;E&gt; collection) // 将 Properties 中的键值对都添加到 Map 中&lt;K,V&gt; void mergePropertiesIntoMap(Properties props, Map&lt;K,V&gt; map)// 返回 List 中最后一个元素&lt;T&gt; T lastElement(List&lt;T&gt; list) // 返回 Set 中最后一个元素&lt;T&gt; T lastElement(Set&lt;T&gt; set) // 返回参数 candidates 中第一个存在于参数 source 中的元素&lt;E&gt; E findFirstMatch(Collection&lt;?&gt; source, Collection&lt;E&gt; candidates)// 返回 List/Set 中指定类型的元素。&lt;T&gt; T findValueOfType(Collection&lt;?&gt; collection, Class&lt;T&gt; type)// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推Object findValueOfType(Collection&lt;?&gt; collection, Class&lt;?&gt;[] types)// 返回 List/Set 中元素的类型Class&lt;?&gt; findCommonElementType(Collection&lt;?&gt; collection) 文件、资源、IO 流FileCopyUtils 输入 123456// 从文件中读入到字节数组中byte[] copyToByteArray(File in)// 从输入流中读入到字节数组中byte[] copyToByteArray(InputStream in)// 从输入流中读入到字符串中String copyToString(Reader in) 输出 123456789101112// 从字节数组到文件void copy(byte[] in, File out)// 从文件到文件int copy(File in, File out)// 从字节数组到输出流void copy(byte[] in, OutputStream out) // 从输入流到输出流int copy(InputStream in, OutputStream out) // 从输入流到输出流int copy(Reader in, Writer out)// 从字符串到输出流void copy(String in, Writer out) ResourceUtils 从资源路径获取文件 123456// 判断字符串是否是一个合法的 URL 字符串。static boolean isUrl(String resourceLocation)// 获取 URLstatic URL getURL(String resourceLocation) // 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）static File getFile(String resourceLocation) Resource 12345678// 文件系统资源 D:\\...FileSystemResource// URL 资源，如 file://... http://...UrlResource// 类路径下的资源，classpth:...ClassPathResource// Web 容器上下文中的资源（jar 包、war 包）ServletContextResource 123456789101112// 判断资源是否存在boolean exists()// 从资源中获得 File 对象File getFile()// 从资源中获得 URI 对象URI getURI()// 从资源中获得 URI 对象URL getURL()// 获得资源的 InputStreamInputStream getInputStream()// 获得资源的描述信息String getDescription() StreamUtils 输入 1234void copy(byte[] in, OutputStream out)int copy(InputStream in, OutputStream out)void copy(String in, Charset charset, OutputStream out)long copyRange(InputStream in, OutputStream out, long start, long end) 输出 1234byte[] copyToByteArray(InputStream in)String copyToString(InputStream in, Charset charset)// 舍弃输入流中的内容int drain(InputStream in) 反射、AOPReflectionUtils 获取方法 123456789101112131415161718// 在类中查找指定方法Method findMethod(Class&lt;?&gt; clazz, String name) // 同上，额外提供方法参数类型作查找条件Method findMethod(Class&lt;?&gt; clazz, String name, Class&lt;?&gt;... paramTypes) // 获得类中所有方法，包括继承而来的Method[] getAllDeclaredMethods(Class&lt;?&gt; leafClass) // 在类中查找指定构造方法Constructor&lt;T&gt; accessibleConstructor(Class&lt;T&gt; clazz, Class&lt;?&gt;... parameterTypes) // 是否是 equals() 方法boolean isEqualsMethod(Method method) // 是否是 hashCode() 方法 boolean isHashCodeMethod(Method method) // 是否是 toString() 方法boolean isToStringMethod(Method method) // 是否是从 Object 类继承而来的方法boolean isObjectMethod(Method method) // 检查一个方法是否声明抛出指定异常boolean declaresException(Method method, Class&lt;?&gt; exceptionType) 执行方法 12345678// 执行方法Object invokeMethod(Method method, Object target) // 同上，提供方法参数Object invokeMethod(Method method, Object target, Object... args) // 取消 Java 权限检查。以便后续执行该私有方法void makeAccessible(Method method) // 取消 Java 权限检查。以便后续执行私有构造方法void makeAccessible(Constructor&lt;?&gt; ctor) 获取字段 123456// 在类中查找指定属性Field findField(Class&lt;?&gt; clazz, String name) // 同上，多提供了属性的类型Field findField(Class&lt;?&gt; clazz, String name, Class&lt;?&gt; type) // 是否为一个 &quot;public static final&quot; 属性boolean isPublicStaticFinal(Field field) 设置字段 123456789101112131415// 获取 target 对象的 field 属性值Object getField(Field field, Object target) // 设置 target 对象的 field 属性值，值为 valuevoid setField(Field field, Object target, Object value) // 同类对象属性对等赋值void shallowCopyFieldState(Object src, Object dest)// 取消 Java 的权限控制检查。以便后续读写该私有属性void makeAccessible(Field field) // 对类的每个属性执行 callbackvoid doWithFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc) // 同上，多了个属性过滤功能。void doWithFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc, ReflectionUtils.FieldFilter ff) // 同上，但不包括继承而来的属性void doWithLocalFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc) AopUtils 判断代理类型 123456// 判断是不是 Spring 代理对象boolean isAopProxy()// 判断是不是 jdk 动态代理对象isJdkDynamicProxy()// 判断是不是 CGLIB 代理对象boolean isCglibProxy() 获取被代理对象的 class 12// 获取被代理的目标 classClass&lt;?&gt; getTargetClass() AopContext 获取当前对象的代理对象 1Object currentProxy()","tags":[]},{"title":"Java8的新特性","date":"2022-01-10T10:33:06.000Z","path":"2022/01/10/Java8的新特性/","text":"Lambda 表达式 Lambda 表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。 在 Java 中，Lambda 表达式的格式是像下面这样 12345// 无参数，无返回值() -&gt; log.info(&quot;Lambda&quot;) // 有参数，有返回值(int a, int b) -&gt; &#123; a+b &#125; 其等价于 12345log.info(&quot;Lambda&quot;);private int plus(int a, int b)&#123; return a+b;&#125; Stream APIStream 是 Java 8 中集合数据处理的利器，很多本来复杂、需要写很多代码的方法，比如过滤、分组等操作，往往使用 Stream 就可以在一行代码搞定，当然也因为 Stream 都是链式操作，一行代码可能会调用好几个方法。 Collection接口提供了 stream()方法，让我们可以在一个集合方便的使用 Stream API 来进行各种操作。值得注意的是，我们执行的任何操作都不会对源集合造成影响，你可以同时在一个集合上提取出多个 stream 进行操作。 Stream 常用 API： of可接收一个泛型对象或可变成泛型集合，构造一个 Stream 对象。 123private static void createStream()&#123; Stream&lt;String&gt; stringStream = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#125; empty创建一个空的 Stream 对象。 concat连接两个 Stream ，不改变其中任何一个 Steam 对象，返回一个新的 Stream 对象。 12345private static void concatStream()&#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); Stream&lt;String&gt; b = Stream.of(&quot;d&quot;,&quot;e&quot;); Stream&lt;String&gt; c = Stream.concat(a,b);&#125; max一般用于求数字集合中的最大值，或者按实体中数字类型的属性比较，拥有最大值的那个实体。它接收一个 Comparator&lt;T&gt;，上面也举到这个例子了，它是一个函数式接口类型，专门用作定义两个对象之间的比较，例如下面这个方法使用了 Integer::compareTo这个方法引用。 12345private static void max()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(2, 2, 100, 5); Integer max = integerStream.max(Integer::compareTo).get(); System.out.println(max);&#125; 当然，我们也可以自己定制一个 Comparator，顺便复习一下 Lambda 表达式形式的方法引用。 123456private static void max()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(2, 2, 100, 5); Comparator&lt;Integer&gt; comparator = (x, y) -&gt; (x.intValue() &lt; y.intValue()) ? -1 : ((x.equals(y)) ? 0 : 1); Integer max = integerStream.max(comparator).get(); System.out.println(max);&#125; min与 max 用法一样，只不过是求最小值。 findFirst获取 Stream 中的第一个元素。 findAny获取 Stream 中的某个元素，如果是串行情况下，一般都会返回第一个元素，并行情况下就不一定了。 count返回元素个数。 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);long x = a.count(); peek建立一个通道，在这个通道中对 Stream 的每个元素执行对应的操作，对应 Consumer&lt;T&gt;的函数式接口，这是一个消费者函数式接口，顾名思义，它是用来消费 Stream 元素的，比如下面这个方法，把每个元素转换成对应的大写字母并输出。 1234private static void peek() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); List&lt;String&gt; list = a.peek(e-&gt;System.out.println(e.toUpperCase())).collect(Collectors.toList());&#125; forEach和 peek 方法类似，都接收一个消费者函数式接口，可以对每个元素进行对应的操作，但是和 peek 不同的是，forEach 执行之后，这个 Stream 就真的被消费掉了，之后这个 Stream 流就没有了，不可以再对它进行后续操作了，而 peek操作完之后，还是一个可操作的 Stream 对象。 正好借着这个说一下，我们在使用 Stream API 的时候，都是一串链式操作，这是因为很多方法，比如接下来要说到的 filter方法等，返回值还是这个 Stream 类型的，也就是被当前方法处理过的 Stream 对象，所以 Stream API 仍然可以使用。 1234private static void forEach() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.forEach(e-&gt;System.out.println(e.toUpperCase()));&#125; forEachOrdered功能与 forEach是一样的，不同的是，forEachOrdered是有顺序保证的，也就是对 Stream 中元素按插入时的顺序进行消费。为什么这么说呢，当开启并行的时候，forEach和 forEachOrdered的效果就不一样了。 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);a.parallel().forEach(e-&gt;System.out.println(e.toUpperCase())); 当使用上面的代码时，输出的结果可能是 B、A、C 或者 A、C、B或者A、B、C，而使用下面的代码，则每次都是 A、 B、C 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);a.parallel().forEachOrdered(e-&gt;System.out.println(e.toUpperCase())); limit获取前 n 条数据，类似于 MySQL 的limit，只不过只能接收一个参数，就是数据条数。 1234private static void limit() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.limit(2).forEach(e-&gt;System.out.println(e));&#125; 上述代码打印的结果是 a、b。 skip跳过前 n 条数据，例如下面代码，返回结果是 c。 1234private static void skip() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.skip(2).forEach(e-&gt;System.out.println(e));&#125; distinct元素去重，例如下面方法返回元素是 a、b、c，将重复的 b 只保留了一个。 1234private static void distinct() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;b&quot;); a.distinct().forEach(e-&gt;System.out.println(e));&#125; sorted有两个重载，一个无参数，另外一个有个 Comparator类型的参数。 无参类型的按照自然顺序进行排序，只适合比较单纯的元素，比如数字、字母等。 1234private static void sorted() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;c&quot;, &quot;b&quot;); a.sorted().forEach(e-&gt;System.out.println(e));&#125; 有参数的需要自定义排序规则，例如下面这个方法，按照第二个字母的大小顺序排序，最后输出的结果是 a1、b3、c6。 1234private static void sortedWithComparator() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a1&quot;, &quot;c6&quot;, &quot;b3&quot;); a.sorted((x,y)-&gt;Integer.parseInt(x.substring(1))&gt;Integer.parseInt(y.substring(1))?1:-1).forEach(e-&gt;System.out.println(e));&#125; 为了更好的说明接下来的几个 API ，我模拟了几条项目中经常用到的类似数据，10条用户信息。 123456789101112131415private static List&lt;User&gt; getUserData() &#123; Random random = new Random(); List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(); user.setUserId(i); user.setUserName(String.format(&quot;古时的风筝 %s 号&quot;, i)); user.setAge(random.nextInt(100)); user.setGender(i % 2); user.setPhone(&quot;18812021111&quot;); user.setAddress(&quot;无&quot;); users.add(user); &#125; return users;&#125; filter用于条件筛选过滤，筛选出符合条件的数据。例如下面这个方法，筛选出性别为 0，年龄大于 50 的记录。 123456789101112131415private static void filter()&#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); stream.filter(user -&gt; user.getGender().equals(0) &amp;&amp; user.getAge()&gt;50).forEach(e-&gt;System.out.println(e)); /** *等同于下面这种形式 匿名内部类 */// stream.filter(new Predicate&lt;User&gt;() &#123;// @Override// public boolean test(User user) &#123;// return user.getGender().equals(0) &amp;&amp; user.getAge()&gt;50;// &#125;// &#125;).forEach(e-&gt;System.out.println(e));&#125; mapmap方法的接口方法声明如下，接受一个 Function函数式接口，把它翻译成映射最合适了，通过原始数据元素，映射出新的类型。 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 而 Function的声明是这样的，观察 apply方法，接受一个 T 型参数，返回一个 R 型参数。用于将一个类型转换成另外一个类型正合适，这也是 map的初衷所在，用于改变当前元素的类型，例如将 Integer 转为 String类型，将 DAO 实体类型，转换为 DTO 实例类型。 当然了，T 和 R 的类型也可以一样，这样的话，就和 peek方法没什么不同了。 1234567891011@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t);&#125; 例如下面这个方法，应该是业务系统的常用需求，将 User 转换为 API 输出的数据格式。 123456789101112private static void map()&#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); List&lt;UserDto&gt; userDtos = stream.map(user -&gt; dao2Dto(user)).collect(Collectors.toList());&#125;private static UserDto dao2Dto(User user)&#123; UserDto dto = new UserDto(); BeanUtils.copyProperties(user, dto); //其他额外处理 return dto;&#125; mapToInt将元素转换成 int 类型，在 map方法的基础上进行封装。 mapToLong将元素转换成 Long 类型，在 map方法的基础上进行封装。 mapToDouble将元素转换成 Double 类型，在 map方法的基础上进行封装。 flatMap这是用在一些比较特别的场景下，当你的 Stream 是以下这几种结构的时候，需要用到 flatMap方法，用于将原有二维结构扁平化。 Stream&lt;String[]&gt; Stream&lt;Set&lt;String&gt;&gt; Stream&lt;List&lt;String&gt;&gt; 以上这三类结构，通过 flatMap方法，可以将结果转化为 Stream&lt;String&gt;这种形式，方便之后的其他操作。 比如下面这个方法，将List&lt;List&lt;User&gt;&gt;扁平处理，然后再使用 map或其他方法进行操作。 123456789private static void flatMap()&#123; List&lt;User&gt; users = getUserData(); List&lt;User&gt; users1 = getUserData(); List&lt;List&lt;User&gt;&gt; userList = new ArrayList&lt;&gt;(); userList.add(users); userList.add(users1); Stream&lt;List&lt;User&gt;&gt; stream = userList.stream(); List&lt;UserDto&gt; userDtos = stream.flatMap(subUserList-&gt;subUserList.stream()).map(user -&gt; dao2Dto(user)).collect(Collectors.toList());&#125; flatMapToInt用法参考 flatMap，将元素扁平为 int 类型，在 flatMap方法的基础上进行封装。 flatMapToLong用法参考 flatMap，将元素扁平为 Long 类型，在 flatMap方法的基础上进行封装。 flatMapToDouble用法参考 flatMap，将元素扁平为 Double 类型，在 flatMap方法的基础上进行封装。 collection在进行了一系列操作之后，我们最终的结果大多数时候并不是为了获取 Stream 类型的数据，而是要把结果变为 List、Map 这样的常用数据结构，而 collection就是为了实现这个目的。 就拿 map 方法的那个例子说明，将对象类型进行转换后，最终我们需要的结果集是一个 List&lt;UserDto &gt;类型的，使用 collect方法将 Stream 转换为我们需要的类型。 下面是 collect接口方法的定义： 1&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 下面这个例子演示了将一个简单的 Integer Stream 过滤出大于 7 的值，然后转换成 List&lt;Integer&gt;集合，用的是 Collectors.toList()这个收集器。 1234private static void collect()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); List&lt;Integer&gt; list = integerStream.filter(s -&gt; s.intValue()&gt;7).collect(Collectors.toList());&#125; 很多同学表示看不太懂这个 Collector是怎么一个意思，来，我们看下面这段代码，这是 collect的另一个重载方法，你可以理解为它的参数是按顺序执行的，这样就清楚了，这就是个 ArrayList 从创建到调用 addAll方法的一个过程。 12345private static void collect()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); List&lt;Integer&gt; list = integerStream.filter(s -&gt; s.intValue()&gt;7).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);&#125; 我们在自定义 Collector的时候其实也是这个逻辑，不过我们根本不用自定义， Collectors已经为我们提供了很多拿来即用的收集器。比如我们经常用到Collectors.toList()、Collectors.toSet()、Collectors.toMap()。另外还有比如Collectors.groupingBy()用来分组，比如下面这个例子，按照 userId 字段分组，返回以 userId 为key，List 为value 的 Map，或者返回每个 key 的个数。 12345// 返回 userId:List&lt;User&gt;Map&lt;String,List&lt;User&gt;&gt; map = user.stream().collect(Collectors.groupingBy(User::getUserId));// 返回 userId:每组个数Map&lt;String,Long&gt; map = user.stream().collect(Collectors.groupingBy(User::getUserId,Collectors.counting())); toArraycollection是返回列表、map 等，toArray是返回数组，有两个重载，一个空参数，返回的是 Object[]。 另一个接收一个 IntFunction&lt;R&gt;类型参数。 1234567891011@FunctionalInterfacepublic interface IntFunction&lt;R&gt; &#123; /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ R apply(int value);&#125; 比如像下面这样使用，参数是 User[]::new也就是new 一个 User 数组，长度为最后的 Stream 长度。 12345private static void toArray() &#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); User[] userArray = stream.filter(user -&gt; user.getGender().equals(0) &amp;&amp; user.getAge() &gt; 50).toArray(User[]::new);&#125; reduce它的作用是每次计算的时候都用到上一次的计算结果，比如求和操作，前两个数的和加上第三个数的和，再加上第四个数，一直加到最后一个数位置，最后返回结果，就是 reduce的工作过程。 12345private static void reduce()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); Integer sum = integerStream.reduce(0,(x,y)-&gt;x+y); System.out.println(sum);&#125; 另外 Collectors好多方法都用到了 reduce，比如 groupingBy、minBy、maxBy等等。 并行 StreamStream 本质上来说就是用来做数据处理的，为了加快处理速度，Stream API 提供了并行处理 Stream 的方式。通过 users.parallelStream()或者users.stream().parallel() 的方式来创建并行 Stream 对象，支持的 API 和普通 Stream 几乎是一致的。","tags":[]},{"title":"SpringBoot整合Mybatis详细流程","date":"2022-01-04T10:38:05.000Z","path":"2022/01/04/SpringBoot整合Mybatis详细流程/","text":"基础环境准备1、数据库准备使用MySQL，创建数据库spring-boot-mybatis，然后在该数据库中创建两个表course和comment，并向表中插入一些基础数据。 12345678910111213141516171819202122232425262728293031323334353637# 创建数据库CREATE DATABASE spring-boot-mybatis; USE spring-boot-mybatis;# 创建表courseDROP TABLE IF EXISTS course; CREATE TABLE course (id int(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;课程id&#x27;, title varchar(200) DEFAULT NULL COMMENT &#x27;课程标题&#x27;,content longtext COMMENT &#x27;课程内容&#x27;,PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO course VALUES (&#x27;1&#x27;, &#x27;Spring Boot基础入门&#x27;, &#x27;从入门到精通讲解...&#x27;); INSERT INTO t_article VALUES (&#x27;2&#x27;, &#x27;Spring Cloud基础入门&#x27;, &#x27;从入门到精通讲解...&#x27;);# 创建表commentDROP TABLE IF EXISTS comment; CREATE TABLE comment (id int(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;评论id&#x27;, content longtext COMMENT &#x27;评论内容&#x27;,author varchar(200) DEFAULT NULL COMMENT &#x27;评论作者&#x27;, c_id int(20) DEFAULT NULL COMMENT &#x27;关联的课程id&#x27;, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;INSERT INTO t_comment VALUES (&#x27;1&#x27;, &#x27;很全、很详细&#x27;, &#x27;lucy&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;2&#x27;, &#x27;赞一个&#x27;, &#x27;tom&#x27;, &#x27;1&#x27;);INSERT INTO t_comment VALUES (&#x27;3&#x27;, &#x27;很详细&#x27;, &#x27;eric&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;4&#x27;, &#x27;很好，非常详细&#x27;, &#x27;张三&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;5&#x27;, &#x27;很不错&#x27;, &#x27;李四&#x27;, &#x27;2&#x27;); 2、创建对应的SpringBoot项目此处省略 3、编写与数据库对应的实体类(set和get方法省略）123456789101112public class Comment &#123; private Integer id; private String content; private String author; private Integer aId;&#125;public class Course &#123; private Integer id; private String title; private String content;&#125; 4、编写SpringBoot的配置文件123456# MySQL数据库连接配置 spring: datasource: url: jdbc:mysql://localhost:3306/springbootmybatis?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: root password: rootroot 配置文件整合Mybatis创建course数据库对应的操作接口CourseMapper123public interface CourseMapper &#123; public Article selectCourse(Integer id);&#125; 创建Mapper对应的XML映射文件resources目录下创建一个统一管理映射文件的包mapper，并在该包下编写与CourseMapper接口方应的映射文件CourseMapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.springboot.mapper.CourseMapper&quot;&gt; &lt;select id=&quot;selectCourse&quot; resultType=&quot;Course&quot;&gt; select * from course &lt;/select&gt;&lt;/mapper&gt; 配置XML映射文件路径在项目中编写的XML映射文件，SpringBoot并不知道，所以无法扫描到自定义编写的XML配置文 件，还必须在全局配置文件application.yml中添加MyBatis映射文件路径的配置，同时需要添加 实体类别名映射路径，示例代码如下 12345mybatis: #配置MyBatis的xml配置文件路径 mapper-locations: classpath:mapper/*.xml #配置XML映射文件中指定的实体类别名路径 type-aliases-package: com.mybatis.entity 编写单元测试进行接口方法测试12345678@Autowiredprivate CourseMapper courseMapper;@Testvoid springBootAndMybatisTest() &#123; Course course = courseMapper.selectCourse(1); System.out.println(course);&#125; 至此SpringBoot整合Mybatis流程已经完成。","tags":[]},{"title":"hutool工具类","date":"2021-12-27T10:06:40.000Z","path":"2021/12/27/hutool工具类/","text":"安装Hutool的安装非常简单，Maven项目中只需在pom.xml添加以下依赖即可。 12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.4.0&lt;/version&gt;&lt;/dependency&gt; 常用工具类 使用一个工具方法代替一段复杂代码，避免复制粘贴代码，可以极大的提高我们的开发效率 Convert类型转换工具类，用于各种类型数据的转换。平时我们转换类型经常会面临类型转换失败的问题，要写try catch代码，有了它，就不用写了！ 123456789101112//转换为字符串int a = 1;String aStr = Convert.toStr(a);//转换为指定类型数组String[] b = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;&#125;;Integer[] bArr = Convert.toIntArray(b);//转换为日期对象String dateStr = &quot;2017-05-06&quot;;Date date = Convert.toDate(dateStr);//转换为列表String[] strArr = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;;List&lt;String&gt; strList = Convert.toList(String.class, strArr); DateUtil日期时间工具类，定义了一些常用的日期时间操作方法。JDK自带的Date和Calendar对象真心不好用，有了它操作日期时间就简单多了！ 12345678910111213141516171819202122232425//Date、long、Calendar之间的相互转换//当前时间Date date = DateUtil.date();//Calendar转Datedate = DateUtil.date(Calendar.getInstance());//时间戳转Datedate = DateUtil.date(System.currentTimeMillis());//自动识别格式转换String dateStr = &quot;2017-03-01&quot;;date = DateUtil.parse(dateStr);//自定义格式化转换date = DateUtil.parse(dateStr, &quot;yyyy-MM-dd&quot;);//格式化输出日期String format = DateUtil.format(date, &quot;yyyy-MM-dd&quot;);//获得年的部分int year = DateUtil.year(date);//获得月份，从0开始计数int month = DateUtil.month(date);//获取某天的开始、结束时间Date beginOfDay = DateUtil.beginOfDay(date);Date endOfDay = DateUtil.endOfDay(date);//计算偏移后的日期时间Date newDate = DateUtil.offset(date, DateField.DAY_OF_MONTH, 2);//计算日期时间之间的偏移量long betweenDay = DateUtil.between(date, newDate, DateUnit.DAY); JSONUtilJSON解析工具类，可用于对象与JSON之间的互相转化。 12345678910111213141516PmsBrand brand = new PmsBrand();brand.setId(1L);brand.setName(&quot;小米&quot;);brand.setShowStatus(1);//对象转化为JSON字符串String jsonStr = JSONUtil.parse(brand).toString();LOGGER.info(&quot;jsonUtil parse:&#123;&#125;&quot;, jsonStr);//JSON字符串转化为对象PmsBrand brandBean = JSONUtil.toBean(jsonStr, PmsBrand.class);LOGGER.info(&quot;jsonUtil toBean:&#123;&#125;&quot;, brandBean);List&lt;PmsBrand&gt; brandList = new ArrayList&lt;&gt;();brandList.add(brand);String jsonListStr = JSONUtil.parse(brandList).toString();//JSON字符串转化为列表brandList = JSONUtil.toList(new JSONArray(jsonListStr), PmsBrand.class);LOGGER.info(&quot;jsonUtil toList:&#123;&#125;&quot;, brandList); StrUtil字符串工具类，定义了一些常用的字符串操作方法。StrUtil比StringUtil名称更短，用起来也更方便！ 1234567891011//判断是否为空字符串String str = &quot;test&quot;;StrUtil.isEmpty(str);StrUtil.isNotEmpty(str);//去除字符串的前后缀StrUtil.removeSuffix(&quot;a.jpg&quot;, &quot;.jpg&quot;);StrUtil.removePrefix(&quot;a.jpg&quot;, &quot;a.&quot;);//格式化字符串String template = &quot;这只是个占位符:&#123;&#125;&quot;;String str2 = StrUtil.format(template, &quot;我是占位符&quot;);LOGGER.info(&quot;/strUtil format:&#123;&#125;&quot;, str2); ClassPathResourceClassPath单一资源访问类，可以获取classPath下的文件，在Tomcat等容器下，classPath一般是WEB-INF/classes。 12345//获取定义在src/main/resources文件夹中的配置文件ClassPathResource resource = new ClassPathResource(&quot;generator.properties&quot;);Properties properties = new Properties();properties.load(resource.getStream());LOGGER.info(&quot;/classPath:&#123;&#125;&quot;, properties); ReflectUtilJava反射工具类，可用于反射获取类的方法及创建对象。 12345678//获取某个类的所有方法Method[] methods = ReflectUtil.getMethods(PmsBrand.class);//获取某个类的指定方法Method method = ReflectUtil.getMethod(PmsBrand.class, &quot;getId&quot;);//使用反射来创建对象PmsBrand pmsBrand = ReflectUtil.newInstance(PmsBrand.class);//反射执行对象的方法ReflectUtil.invoke(pmsBrand, &quot;setId&quot;, 1); NumberUtil数字处理工具类，可用于各种类型数字的加减乘除操作及类型判断。 123456789101112131415double n1 = 1.234;double n2 = 1.234;double result;//对float、double、BigDecimal做加减乘除操作result = NumberUtil.add(n1, n2);result = NumberUtil.sub(n1, n2);result = NumberUtil.mul(n1, n2);result = NumberUtil.div(n1, n2);//保留两位小数BigDecimal roundNum = NumberUtil.round(n1, 2);String n3 = &quot;1.234&quot;;//判断是否为数字、整数、浮点数NumberUtil.isNumber(n3);NumberUtil.isInteger(n3);NumberUtil.isDouble(n3); BeanUtilJavaBean工具类，可用于Map与JavaBean对象的互相转换以及对象属性的拷贝。 1234567891011121314PmsBrand brand = new PmsBrand();brand.setId(1L);brand.setName(&quot;小米&quot;);brand.setShowStatus(0);//Bean转MapMap&lt;String, Object&gt; map = BeanUtil.beanToMap(brand);LOGGER.info(&quot;beanUtil bean to map:&#123;&#125;&quot;, map);//Map转BeanPmsBrand mapBrand = BeanUtil.mapToBean(map, PmsBrand.class, false);LOGGER.info(&quot;beanUtil map to bean:&#123;&#125;&quot;, mapBrand);//Bean属性拷贝PmsBrand copyBrand = new PmsBrand();BeanUtil.copyProperties(brand, copyBrand);LOGGER.info(&quot;beanUtil copy properties:&#123;&#125;&quot;, copyBrand); CollUtil集合操作的工具类，定义了一些常用的集合操作。 123456789101112131415//数组转换为列表String[] array = new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;;List&lt;String&gt; list = CollUtil.newArrayList(array);//join：数组转字符串时添加连接符号String joinStr = CollUtil.join(list, &quot;,&quot;);LOGGER.info(&quot;collUtil join:&#123;&#125;&quot;, joinStr);//将以连接符号分隔的字符串再转换为列表List&lt;String&gt; splitList = StrUtil.split(joinStr, &#x27;,&#x27;);LOGGER.info(&quot;collUtil split:&#123;&#125;&quot;, splitList);//创建新的Map、Set、ListHashMap&lt;Object, Object&gt; newMap = CollUtil.newHashMap();HashSet&lt;Object&gt; newHashSet = CollUtil.newHashSet();ArrayList&lt;Object&gt; newList = CollUtil.newArrayList();//判断列表是否为空CollUtil.isEmpty(list); MapUtilMap操作工具类，可用于创建Map对象及判断Map是否为空。 123456789//将多个键值对加入到Map中Map&lt;Object, Object&gt; map = MapUtil.of(new String[][]&#123; &#123;&quot;key1&quot;, &quot;value1&quot;&#125;, &#123;&quot;key2&quot;, &quot;value2&quot;&#125;, &#123;&quot;key3&quot;, &quot;value3&quot;&#125;&#125;);//判断Map是否为空MapUtil.isEmpty(map);MapUtil.isNotEmpty(map); AnnotationUtil注解工具类，可用于获取注解与注解中指定的值。 123456789//获取指定类、方法、字段、构造器上的注解列表Annotation[] annotationList = AnnotationUtil.getAnnotations(HutoolController.class, false);LOGGER.info(&quot;annotationUtil annotations:&#123;&#125;&quot;, annotationList);//获取指定类型注解Api api = AnnotationUtil.getAnnotation(HutoolController.class, Api.class);LOGGER.info(&quot;annotationUtil api value:&#123;&#125;&quot;, api.description());//获取指定类型注解的值Object annotationValue = AnnotationUtil.getAnnotationValue(HutoolController.class, RequestMapping.class);复制代码 SecureUtil加密解密工具类，可用于MD5加密。 12345//MD5加密String str = &quot;123456&quot;;String md5Str = SecureUtil.md5(str);LOGGER.info(&quot;secureUtil md5:&#123;&#125;&quot;, md5Str);复制代码 CaptchaUtil验证码工具类，可用于生成图形验证码。 12345678910111213//生成验证码图片LineCaptcha lineCaptcha = CaptchaUtil.createLineCaptcha(200, 100);try &#123; request.getSession().setAttribute(&quot;CAPTCHA_KEY&quot;, lineCaptcha.getCode()); response.setContentType(&quot;image/png&quot;);//告诉浏览器输出内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);//禁止浏览器缓存 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); lineCaptcha.write(response.getOutputStream());&#125; catch (IOException e) &#123; e.printStackTrace();&#125;复制代码 Validator字段验证器，可以对不同格式的字符串进行验证，比如邮箱、手机号、IP等格式。 12345678910111213141516171819202122//判断是否为邮箱地址boolean result = Validator.isEmail(&quot;macro@qq.com&quot;);LOGGER.info(&quot;Validator isEmail:&#123;&#125;&quot;, result);//判断是否为手机号码result = Validator.isMobile(&quot;18911111111&quot;);LOGGER.info(&quot;Validator isMobile:&#123;&#125;&quot;, result);//判断是否为IPV4地址result = Validator.isIpv4(&quot;192.168.3.101&quot;);LOGGER.info(&quot;Validator isIpv4:&#123;&#125;&quot;, result);//判断是否为汉字result = Validator.isChinese(&quot;你好&quot;);LOGGER.info(&quot;Validator isChinese:&#123;&#125;&quot;, result);//判断是否为身份证号码（18位中国）result = Validator.isCitizenId(&quot;123456&quot;);LOGGER.info(&quot;Validator isCitizenId:&#123;&#125;&quot;, result);//判断是否为URLresult = Validator.isUrl(&quot;http://www.baidu.com&quot;);LOGGER.info(&quot;Validator isUrl:&#123;&#125;&quot;, result);//判断是否为生日result = Validator.isBirthday(&quot;2020-02-01&quot;);LOGGER.info(&quot;Validator isBirthday:&#123;&#125;&quot;, result);复制代码 DigestUtil摘要算法工具类，支持MD5、SHA-256、Bcrypt等算法。 123456789101112String password = &quot;123456&quot;;//计算MD5摘要值，并转为16进制字符串String result = DigestUtil.md5Hex(password);LOGGER.info(&quot;DigestUtil md5Hex:&#123;&#125;&quot;, result);//计算SHA-256摘要值，并转为16进制字符串result = DigestUtil.sha256Hex(password);LOGGER.info(&quot;DigestUtil sha256Hex:&#123;&#125;&quot;, result);//生成Bcrypt加密后的密文，并校验String hashPwd = DigestUtil.bcrypt(password);boolean check = DigestUtil.bcryptCheck(password,hashPwd);LOGGER.info(&quot;DigestUtil bcryptCheck:&#123;&#125;&quot;, check);复制代码 HttpUtilHttp请求工具类，可以发起GET/POST等请求。 12String response = HttpUtil.get(&quot;http://localhost:8080/hutool/covert&quot;);LOGGER.info(&quot;HttpUtil get:&#123;&#125;&quot;, response); hutool官网www.hutool.cn/","tags":[]},{"title":"Hello World","date":"2021-12-17T06:49:33.859Z","path":"2021/12/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]