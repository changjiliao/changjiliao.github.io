[{"title":"explain详解.md","date":"2022-06-27T06:37:19.000Z","path":"2022/06/27/explain详解/","text":"explain详解简介​ 使用explain关键字可以模拟优化器执行sql语句，从而知道MySQL是如何处理你的sql语句。分析你的查询语句或是表结构的性能瓶颈。 那使用explain具体可以得到哪些信息呢？ 根据id字段可以得到表的读取顺序。数据读取操作的操作类型。哪些索引可以使用。哪些索引被实际使用。表之间的引用。每张表有多少行被优化器查询。用法在select查询语句前加explain关键字： explain select * from user; 可以看到查询结果有12个字段，接下来我们对这12个字段进行详细的介绍 介绍id select查询的序列号，包含一组数字，标识查询中执行select子句或操作表的顺序。 有三种情况： id相同，表示查询优化器执行顺序是由上至下。 id不同，如果是子查询，id的序号会递增，id的值越大优先级越高，越先被执行。 id相同和不同的情况都存在，那么id相同的为一组，组内由上至下顺序执行；所有组中，id越大优先级越高，越先被执行。 select_type select_type的值有6个，主要用于区别普通查询、联合查询、子查询等复杂查询，分别是： SIMPLE：简单的select查询，查询中不使用子查询或者union。PROMARY：查询中若包含任何复杂的子查询，最外层查询则被标记为PRIMARY，就是最后执行的那个查询。SUBQUERY：在select或where列表中包含了子查询。DERIVED：在from列表中包含的子查询会被标记为DERIVED(衍生)，MySQL会递归执行这些子查询，把结果放在临时表里。UNION：若第二个select出现再union之后，则被标记为union；若union包含在from字句的子查询中，外层select江北标记为DERIVED。UNION RESULT：在union表获取结果的select会被标记为UNION RESULTtable 当前行数据是关于哪张表。 partitions 版本5.7以前，该项是explain partitions显示的选项，5.7以后成为了默认选项。该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。 type 显示查询使用了何种类型，从最好到最差依次是： system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL system：表只有一行记录（等于系统表），这是const类型的额特例，平时不会出现，这个也可以忽略不计。 const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键止于where列表中，MySQL就能将该查询转换为一个常量。 eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。 ref：非唯一性索引扫描，返回匹配每个单独之的所有行，本质上也是一种索引访问，他返回所有匹配每个单独值的行，然而，她可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。 range：只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为他只需要开始于索引的某一个点，而结束于另一点，不用扫描全部索引。 index：全索引扫描，index与ALL区别为index类型只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小。（虽然all和index都是读全表，但是index是从索引中读取的，而all是从硬盘中读的）。 ALL：全表扫描。 完整的：system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;ALL。 备注：一般来说，保证查询至少到达range级别，最好能达到ref。 possible_keys 查询可能使用到的索引都会在这里列出来，可能是一个或多个，查询涉及到的字段上若存在索引，则索引将被列出，但是不一定被查询实际应用。 key 实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在key列表中。 key_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引长度，在不损失精确性的情况下，长度越短越好，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，因为key_len是根据表定义计算而得，不是通过表内检索。 ref 显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值。 rows 根据表统计信息及索引需用情况，大致估算出找到所需的记录所需读取的行数。 filtered 这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。这个字段不重要 Extra 十分重要的额外信息。 using fliesort：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL无法利用索引完成的排序操作称为“文件排序”。需要优化。 using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用了临时表，常见于排序order by 和分组查询group by。需要优化。 using index：标识响应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！如果同时出现using where 表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。 覆盖索引（Covering Index）：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。 using where：表明使用了where过滤。 using join buffer：使用了连接缓存。 impossible where：where子句的值总是false，不能用来获取任何元组。 select tables optimized away：在没有group by 子句的情况下，基于索引优化min/max操作或者对于MyISAM存储引擎优化count（*）操作，不必等到执行阶段再计算，查询执行计划生成阶段即完成优化。 distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。","tags":[]},{"title":"java8的日期时间与字符串的转换.md","date":"2022-04-20T07:43:08.000Z","path":"2022/04/20/java8的日期时间与字符串的转换-md/","text":"LocalDate用于处理日期，yyyy-MM-dd格式。 LocalDate的基本用法LocalDate localDate = LocalDate.now();###获取当前日期String format = LocalDate.now().format(DateTimeFormatter.ofPattern(“yyyy-MM-dd”));###LocalDate转StringLocalDate parse = LocalDate.parse(“2020-01-17”, DateTimeFormatter.ofPattern(“yyyy-MM-dd”));###String转LocalDateDate date = Date.from(LocalDate.now().atStartOfDay(ZoneId.systemDefault()).toInstant());###LocalDate转DateLocalDate localDate = new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();###Date转LocalDate LocalTime用于处理时间，HH:mm:ss格式。 LocalTime的基本用法LocalTime now = LocalTime.now();###获取当前时间String format = LocalTime.now().format(DateTimeFormatter.ofPattern(“HH:mm:ss”));###LocalTime转StringLocalTime parse = LocalTime.parse(“14:32:24”, DateTimeFormatter.ofPattern(“HH:mm:ss”));###String转LocalTime这个需要转换成LocalDateTime在转换成LocalTimeLocalTime localTime = LocalTime.now(); LocalDate localDate = LocalDate.now(); LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime); ZoneId zone = ZoneId.systemDefault(); Instant instant = localDateTime.atZone(zone).toInstant(); java.util.Date date = Date.from(instant);###LocalTime转DateLocalTime localTime = new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalTime();###Date转LocalTime LocalDateTime用于处理 yyyy-MM-dd HH:mm:ss格式的时间 LocalDateTime的基本用法LocalDateTime localDateTime= LocalDateTime.now();###获取当前时间LocalDateTime.now().format(DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”))###LocalDateTime转StringLocalDateTime parse = LocalDateTime.parse(“2020-01-17 11:52:04”, DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”));###String转LocalDateTimeDate from = Date.from(LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant());###LocalDateTime转DateLocalDateTime localDateTime = LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());###Date转LocalDateTime","tags":[]},{"title":"list常用方法.md","date":"2022-03-22T03:02:41.000Z","path":"2022/03/22/list常用方法-md/","text":"list常用方法1、count()方法用于统计某个元素在列表中出现的次数语法：list.count(obj)obj–列表中统计的对象2、index()方法用于从列表中找出某个值第一个匹配项的索引位置（从左至右查找），返回查找对象的索引位置，如果没有找到对象则抛出异常。语法：list.index(x[, start[x,end]])x– 查找的对象。start– 可选，查找的起始位置。end– 可选，查找的结束位置。 3、insert()方法用于将指定对象插入列表的指定位置语法：list.insert(index, obj)index – 对象obj需要插入的索引位置obj – 要插入列表中的对象 insert()方法与append()、extend()方法区别：（1）insert()方法可以插入指定的任意位置，append()和extend()方法只能在列表末尾插入（2）insert()方法是将序列如列表、元组、字典当做一个新的元素插入，extend()方法是将一个序列中的所有元素依次在原列表尾部插入4、pop()方法用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值语法：list.pop(index) index是索引值，默认为-1 即删除最后一个元素 5、remove()方法用于移除列表中某个值的第一个匹配项。语法:list.remove(obj) obj–列表中要移除的对象 pop()与remove()的区别（1）pop是删除指定索引位置的元素，是根据索引删除，remove是根据要删除的对象从左至右进行查找，删除第一个匹配的元素6、reverse()方法用于将列表中的元素反向排序语法：list.reverse()7、sort()方法用于对列表进行排序，如果指定参数，则使用比较函数指定的比较函数语法：list.sort(key=None ,reverse=False)key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。(没有使用过，暂不理解)reverse – 排序规则，reverse=True 降序 ，reverse=False 升序 默认是升序注意：不同数据类型之间不能进行比较排序，如str和int不能一起比较排序，str、int和tuple、list、dict不能一起比较排序，list不能和其他非list类型比较排序，运行会报错 8、clear()方法用户清空列表语法：list.clear() clear()方法相当于del list[:]9、copy()方法用于复制列表，返回复制后的新列表语法：list.copy()注意：修改List不会影响复制后的新列表，修改List中的对象，会影响复制后新列表（改列表不会互相影响，但是修改列表里面的对象会影响到对方列表里面对象）","tags":[]},{"title":"springboot内置工具类","date":"2022-01-25T05:54:53.000Z","path":"2022/01/25/springboot内置工具类/","text":"断言 断言是一个逻辑判断，用于检查不应该发生的情况 Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数-enableassertions开启 SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查 123456789101112131415161718// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行// 参数 message 参数用于定制异常信息。void notNull(Object object, String message)// 要求参数必须空（Null），否则抛出异常，不予『放行』。// 和 notNull() 方法断言规则相反void isNull(Object object, String message)// 要求参数必须为真（True），否则抛出异常，不予『放行』。void isTrue(boolean expression, String message)// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行void notEmpty(Collection collection, String message)// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行void hasLength(String text, String message)// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行void hasText(String text, String message)// 要求参数是指定类型的实例，否则抛出异常，不予放行void isInstanceOf(Class type, Object obj, String message)// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行void isAssignable(Class superType, Class subType, String message) 对象、数组、集合ObjectUtils 获取对象的基本信息 123456789101112// 获取对象的类名。参数为 null 时，返回字符串：&quot;null&quot; String nullSafeClassName(Object obj)// 参数为 null 时，返回 0int nullSafeHashCode(Object object)// 参数为 null 时，返回字符串：&quot;null&quot;String nullSafeToString(boolean[] array)// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 String getIdentityHexString(Object obj)// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：&quot;&quot; String identityToString(Object obj)// 相当于 toString()方法，但参数为 null 时，返回字符串：&quot;&quot;String getDisplayString(Object obj) 判断工具 1234567891011121314151617// 判断数组是否为空boolean isEmpty(Object[] array)// 判断参数对象是否是数组boolean isArray(Object obj)// 判断数组中是否包含指定元素boolean containsElement(Object[] array, Object element)// 相等，或同为 null时，返回 trueboolean nullSafeEquals(Object o1, Object o2)/*判断参数对象是否为空，判断标准为： Optional: Optional.empty() Array: length == 0CharSequence: length == 0 Collection: Collection.isEmpty() Map: Map.isEmpty() */boolean isEmpty(Object obj) 其他工具方法 1234// 向参数数组的末尾追加新元素，并返回一个新数组&lt;A, O extends A&gt; A[] addObjectToArray(A[] array, O obj)// 原生基础类型数组 --&gt; 包装类数组Object[] toObjectArray(Object source) StringUtils 字符串判断工具 12345678910111213141516// 判断字符串是否为 null，或 &quot;&quot;。注意，包含空白符的字符串为非空boolean isEmpty(Object str)// 判断字符串是否是以指定内容结束。忽略大小写boolean endsWithIgnoreCase(String str, String suffix)// 判断字符串是否已指定内容开头。忽略大小写boolean startsWithIgnoreCase(String str, String prefix) // 是否包含空白符boolean containsWhitespace(String str)// 判断字符串非空且长度不为 0，即，Not Emptyboolean hasLength(CharSequence str)// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blankboolean hasText(CharSequence str)// 判断字符串指定索引处是否包含一个子串。boolean substringMatch(CharSequence str, int index, CharSequence substring)// 计算一个字符串中指定子串的出现次数int countOccurrencesOf(String str, String sub) 字符串操作工具 12345678910111213141516171819202122// 查找并替换指定子串String replace(String inString, String oldPattern, String newPattern)// 去除尾部的特定字符String trimTrailingCharacter(String str, char trailingCharacter) // 去除头部的特定字符String trimLeadingCharacter(String str, char leadingCharacter)// 去除头部的空白符String trimLeadingWhitespace(String str)// 去除头部的空白符String trimTrailingWhitespace(String str)// 去除头部和尾部的空白符String trimWhitespace(String str)// 删除开头、结尾和中间的空白符String trimAllWhitespace(String str)// 删除指定子串String delete(String inString, String pattern)// 删除指定字符（可以是多个）String deleteAny(String inString, String charsToDelete)// 对数组的每一项执行 trim() 方法String[] trimArrayElements(String[] array)// 将 URL 字符串进行解码String uriDecode(String source, Charset charset) 路径相关工具方法 1234567891011121314// 解析路径字符串，优化其中的 “..” String cleanPath(String path)// 解析路径字符串，解析出文件名部分String getFilename(String path)// 解析路径字符串，解析出文件后缀名String getFilenameExtension(String path)// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” boolean pathEquals(String path1, String path2)// 删除文件路径名中的后缀部分String stripFilenameExtension(String path) // 以 “. 作为分隔符，获取其最后一部分String unqualify(String qualifiedName)// 以指定字符作为分隔符，获取其最后一部分String unqualify(String qualifiedName, char separator) CollectionUtils 集合判断工具 123456789101112// 判断 List/Set 是否为空boolean isEmpty(Collection&lt;?&gt; collection)// 判断 Map 是否为空boolean isEmpty(Map&lt;?,?&gt; map)// 判断 List/Set 中是否包含某个对象boolean containsInstance(Collection&lt;?&gt; collection, Object element)// 以迭代器的方式，判断 List/Set 中是否包含某个对象boolean contains(Iterator&lt;?&gt; iterator, Object element)// 判断 List/Set 是否包含某些对象中的任意一个boolean containsAny(Collection&lt;?&gt; source, Collection&lt;?&gt; candidates)// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素boolean hasUniqueObject(Collection&lt;?&gt; collection) 集合操作工具 12345678910111213141516// 将 Array 中的元素都添加到 List/Set 中&lt;E&gt; void mergeArrayIntoCollection(Object array, Collection&lt;E&gt; collection) // 将 Properties 中的键值对都添加到 Map 中&lt;K,V&gt; void mergePropertiesIntoMap(Properties props, Map&lt;K,V&gt; map)// 返回 List 中最后一个元素&lt;T&gt; T lastElement(List&lt;T&gt; list) // 返回 Set 中最后一个元素&lt;T&gt; T lastElement(Set&lt;T&gt; set) // 返回参数 candidates 中第一个存在于参数 source 中的元素&lt;E&gt; E findFirstMatch(Collection&lt;?&gt; source, Collection&lt;E&gt; candidates)// 返回 List/Set 中指定类型的元素。&lt;T&gt; T findValueOfType(Collection&lt;?&gt; collection, Class&lt;T&gt; type)// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推Object findValueOfType(Collection&lt;?&gt; collection, Class&lt;?&gt;[] types)// 返回 List/Set 中元素的类型Class&lt;?&gt; findCommonElementType(Collection&lt;?&gt; collection) 文件、资源、IO 流FileCopyUtils 输入 123456// 从文件中读入到字节数组中byte[] copyToByteArray(File in)// 从输入流中读入到字节数组中byte[] copyToByteArray(InputStream in)// 从输入流中读入到字符串中String copyToString(Reader in) 输出 123456789101112// 从字节数组到文件void copy(byte[] in, File out)// 从文件到文件int copy(File in, File out)// 从字节数组到输出流void copy(byte[] in, OutputStream out) // 从输入流到输出流int copy(InputStream in, OutputStream out) // 从输入流到输出流int copy(Reader in, Writer out)// 从字符串到输出流void copy(String in, Writer out) ResourceUtils 从资源路径获取文件 123456// 判断字符串是否是一个合法的 URL 字符串。static boolean isUrl(String resourceLocation)// 获取 URLstatic URL getURL(String resourceLocation) // 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）static File getFile(String resourceLocation) Resource 12345678// 文件系统资源 D:\\...FileSystemResource// URL 资源，如 file://... http://...UrlResource// 类路径下的资源，classpth:...ClassPathResource// Web 容器上下文中的资源（jar 包、war 包）ServletContextResource 123456789101112// 判断资源是否存在boolean exists()// 从资源中获得 File 对象File getFile()// 从资源中获得 URI 对象URI getURI()// 从资源中获得 URI 对象URL getURL()// 获得资源的 InputStreamInputStream getInputStream()// 获得资源的描述信息String getDescription() StreamUtils 输入 1234void copy(byte[] in, OutputStream out)int copy(InputStream in, OutputStream out)void copy(String in, Charset charset, OutputStream out)long copyRange(InputStream in, OutputStream out, long start, long end) 输出 1234byte[] copyToByteArray(InputStream in)String copyToString(InputStream in, Charset charset)// 舍弃输入流中的内容int drain(InputStream in) 反射、AOPReflectionUtils 获取方法 123456789101112131415161718// 在类中查找指定方法Method findMethod(Class&lt;?&gt; clazz, String name) // 同上，额外提供方法参数类型作查找条件Method findMethod(Class&lt;?&gt; clazz, String name, Class&lt;?&gt;... paramTypes) // 获得类中所有方法，包括继承而来的Method[] getAllDeclaredMethods(Class&lt;?&gt; leafClass) // 在类中查找指定构造方法Constructor&lt;T&gt; accessibleConstructor(Class&lt;T&gt; clazz, Class&lt;?&gt;... parameterTypes) // 是否是 equals() 方法boolean isEqualsMethod(Method method) // 是否是 hashCode() 方法 boolean isHashCodeMethod(Method method) // 是否是 toString() 方法boolean isToStringMethod(Method method) // 是否是从 Object 类继承而来的方法boolean isObjectMethod(Method method) // 检查一个方法是否声明抛出指定异常boolean declaresException(Method method, Class&lt;?&gt; exceptionType) 执行方法 12345678// 执行方法Object invokeMethod(Method method, Object target) // 同上，提供方法参数Object invokeMethod(Method method, Object target, Object... args) // 取消 Java 权限检查。以便后续执行该私有方法void makeAccessible(Method method) // 取消 Java 权限检查。以便后续执行私有构造方法void makeAccessible(Constructor&lt;?&gt; ctor) 获取字段 123456// 在类中查找指定属性Field findField(Class&lt;?&gt; clazz, String name) // 同上，多提供了属性的类型Field findField(Class&lt;?&gt; clazz, String name, Class&lt;?&gt; type) // 是否为一个 &quot;public static final&quot; 属性boolean isPublicStaticFinal(Field field) 设置字段 123456789101112131415// 获取 target 对象的 field 属性值Object getField(Field field, Object target) // 设置 target 对象的 field 属性值，值为 valuevoid setField(Field field, Object target, Object value) // 同类对象属性对等赋值void shallowCopyFieldState(Object src, Object dest)// 取消 Java 的权限控制检查。以便后续读写该私有属性void makeAccessible(Field field) // 对类的每个属性执行 callbackvoid doWithFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc) // 同上，多了个属性过滤功能。void doWithFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc, ReflectionUtils.FieldFilter ff) // 同上，但不包括继承而来的属性void doWithLocalFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc) AopUtils 判断代理类型 123456// 判断是不是 Spring 代理对象boolean isAopProxy()// 判断是不是 jdk 动态代理对象isJdkDynamicProxy()// 判断是不是 CGLIB 代理对象boolean isCglibProxy() 获取被代理对象的 class 12// 获取被代理的目标 classClass&lt;?&gt; getTargetClass() AopContext 获取当前对象的代理对象 1Object currentProxy()","tags":[]},{"title":"Java8的新特性","date":"2022-01-10T10:33:06.000Z","path":"2022/01/10/Java8的新特性/","text":"Lambda 表达式 Lambda 表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。 在 Java 中，Lambda 表达式的格式是像下面这样 12345// 无参数，无返回值() -&gt; log.info(&quot;Lambda&quot;) // 有参数，有返回值(int a, int b) -&gt; &#123; a+b &#125; 其等价于 12345log.info(&quot;Lambda&quot;);private int plus(int a, int b)&#123; return a+b;&#125; Stream APIStream 是 Java 8 中集合数据处理的利器，很多本来复杂、需要写很多代码的方法，比如过滤、分组等操作，往往使用 Stream 就可以在一行代码搞定，当然也因为 Stream 都是链式操作，一行代码可能会调用好几个方法。 Collection接口提供了 stream()方法，让我们可以在一个集合方便的使用 Stream API 来进行各种操作。值得注意的是，我们执行的任何操作都不会对源集合造成影响，你可以同时在一个集合上提取出多个 stream 进行操作。 Stream 常用 API： of可接收一个泛型对象或可变成泛型集合，构造一个 Stream 对象。 123private static void createStream()&#123; Stream&lt;String&gt; stringStream = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#125; empty创建一个空的 Stream 对象。 concat连接两个 Stream ，不改变其中任何一个 Steam 对象，返回一个新的 Stream 对象。 12345private static void concatStream()&#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); Stream&lt;String&gt; b = Stream.of(&quot;d&quot;,&quot;e&quot;); Stream&lt;String&gt; c = Stream.concat(a,b);&#125; max一般用于求数字集合中的最大值，或者按实体中数字类型的属性比较，拥有最大值的那个实体。它接收一个 Comparator&lt;T&gt;，上面也举到这个例子了，它是一个函数式接口类型，专门用作定义两个对象之间的比较，例如下面这个方法使用了 Integer::compareTo这个方法引用。 12345private static void max()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(2, 2, 100, 5); Integer max = integerStream.max(Integer::compareTo).get(); System.out.println(max);&#125; 当然，我们也可以自己定制一个 Comparator，顺便复习一下 Lambda 表达式形式的方法引用。 123456private static void max()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(2, 2, 100, 5); Comparator&lt;Integer&gt; comparator = (x, y) -&gt; (x.intValue() &lt; y.intValue()) ? -1 : ((x.equals(y)) ? 0 : 1); Integer max = integerStream.max(comparator).get(); System.out.println(max);&#125; min与 max 用法一样，只不过是求最小值。 findFirst获取 Stream 中的第一个元素。 findAny获取 Stream 中的某个元素，如果是串行情况下，一般都会返回第一个元素，并行情况下就不一定了。 count返回元素个数。 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);long x = a.count(); peek建立一个通道，在这个通道中对 Stream 的每个元素执行对应的操作，对应 Consumer&lt;T&gt;的函数式接口，这是一个消费者函数式接口，顾名思义，它是用来消费 Stream 元素的，比如下面这个方法，把每个元素转换成对应的大写字母并输出。 1234private static void peek() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); List&lt;String&gt; list = a.peek(e-&gt;System.out.println(e.toUpperCase())).collect(Collectors.toList());&#125; forEach和 peek 方法类似，都接收一个消费者函数式接口，可以对每个元素进行对应的操作，但是和 peek 不同的是，forEach 执行之后，这个 Stream 就真的被消费掉了，之后这个 Stream 流就没有了，不可以再对它进行后续操作了，而 peek操作完之后，还是一个可操作的 Stream 对象。 正好借着这个说一下，我们在使用 Stream API 的时候，都是一串链式操作，这是因为很多方法，比如接下来要说到的 filter方法等，返回值还是这个 Stream 类型的，也就是被当前方法处理过的 Stream 对象，所以 Stream API 仍然可以使用。 1234private static void forEach() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.forEach(e-&gt;System.out.println(e.toUpperCase()));&#125; forEachOrdered功能与 forEach是一样的，不同的是，forEachOrdered是有顺序保证的，也就是对 Stream 中元素按插入时的顺序进行消费。为什么这么说呢，当开启并行的时候，forEach和 forEachOrdered的效果就不一样了。 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);a.parallel().forEach(e-&gt;System.out.println(e.toUpperCase())); 当使用上面的代码时，输出的结果可能是 B、A、C 或者 A、C、B或者A、B、C，而使用下面的代码，则每次都是 A、 B、C 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);a.parallel().forEachOrdered(e-&gt;System.out.println(e.toUpperCase())); limit获取前 n 条数据，类似于 MySQL 的limit，只不过只能接收一个参数，就是数据条数。 1234private static void limit() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.limit(2).forEach(e-&gt;System.out.println(e));&#125; 上述代码打印的结果是 a、b。 skip跳过前 n 条数据，例如下面代码，返回结果是 c。 1234private static void skip() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.skip(2).forEach(e-&gt;System.out.println(e));&#125; distinct元素去重，例如下面方法返回元素是 a、b、c，将重复的 b 只保留了一个。 1234private static void distinct() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;b&quot;); a.distinct().forEach(e-&gt;System.out.println(e));&#125; sorted有两个重载，一个无参数，另外一个有个 Comparator类型的参数。 无参类型的按照自然顺序进行排序，只适合比较单纯的元素，比如数字、字母等。 1234private static void sorted() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;c&quot;, &quot;b&quot;); a.sorted().forEach(e-&gt;System.out.println(e));&#125; 有参数的需要自定义排序规则，例如下面这个方法，按照第二个字母的大小顺序排序，最后输出的结果是 a1、b3、c6。 1234private static void sortedWithComparator() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a1&quot;, &quot;c6&quot;, &quot;b3&quot;); a.sorted((x,y)-&gt;Integer.parseInt(x.substring(1))&gt;Integer.parseInt(y.substring(1))?1:-1).forEach(e-&gt;System.out.println(e));&#125; 为了更好的说明接下来的几个 API ，我模拟了几条项目中经常用到的类似数据，10条用户信息。 123456789101112131415private static List&lt;User&gt; getUserData() &#123; Random random = new Random(); List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(); user.setUserId(i); user.setUserName(String.format(&quot;古时的风筝 %s 号&quot;, i)); user.setAge(random.nextInt(100)); user.setGender(i % 2); user.setPhone(&quot;18812021111&quot;); user.setAddress(&quot;无&quot;); users.add(user); &#125; return users;&#125; filter用于条件筛选过滤，筛选出符合条件的数据。例如下面这个方法，筛选出性别为 0，年龄大于 50 的记录。 123456789101112131415private static void filter()&#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); stream.filter(user -&gt; user.getGender().equals(0) &amp;&amp; user.getAge()&gt;50).forEach(e-&gt;System.out.println(e)); /** *等同于下面这种形式 匿名内部类 */// stream.filter(new Predicate&lt;User&gt;() &#123;// @Override// public boolean test(User user) &#123;// return user.getGender().equals(0) &amp;&amp; user.getAge()&gt;50;// &#125;// &#125;).forEach(e-&gt;System.out.println(e));&#125; mapmap方法的接口方法声明如下，接受一个 Function函数式接口，把它翻译成映射最合适了，通过原始数据元素，映射出新的类型。 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 而 Function的声明是这样的，观察 apply方法，接受一个 T 型参数，返回一个 R 型参数。用于将一个类型转换成另外一个类型正合适，这也是 map的初衷所在，用于改变当前元素的类型，例如将 Integer 转为 String类型，将 DAO 实体类型，转换为 DTO 实例类型。 当然了，T 和 R 的类型也可以一样，这样的话，就和 peek方法没什么不同了。 1234567891011@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t);&#125; 例如下面这个方法，应该是业务系统的常用需求，将 User 转换为 API 输出的数据格式。 123456789101112private static void map()&#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); List&lt;UserDto&gt; userDtos = stream.map(user -&gt; dao2Dto(user)).collect(Collectors.toList());&#125;private static UserDto dao2Dto(User user)&#123; UserDto dto = new UserDto(); BeanUtils.copyProperties(user, dto); //其他额外处理 return dto;&#125; mapToInt将元素转换成 int 类型，在 map方法的基础上进行封装。 mapToLong将元素转换成 Long 类型，在 map方法的基础上进行封装。 mapToDouble将元素转换成 Double 类型，在 map方法的基础上进行封装。 flatMap这是用在一些比较特别的场景下，当你的 Stream 是以下这几种结构的时候，需要用到 flatMap方法，用于将原有二维结构扁平化。 Stream&lt;String[]&gt; Stream&lt;Set&lt;String&gt;&gt; Stream&lt;List&lt;String&gt;&gt; 以上这三类结构，通过 flatMap方法，可以将结果转化为 Stream&lt;String&gt;这种形式，方便之后的其他操作。 比如下面这个方法，将List&lt;List&lt;User&gt;&gt;扁平处理，然后再使用 map或其他方法进行操作。 123456789private static void flatMap()&#123; List&lt;User&gt; users = getUserData(); List&lt;User&gt; users1 = getUserData(); List&lt;List&lt;User&gt;&gt; userList = new ArrayList&lt;&gt;(); userList.add(users); userList.add(users1); Stream&lt;List&lt;User&gt;&gt; stream = userList.stream(); List&lt;UserDto&gt; userDtos = stream.flatMap(subUserList-&gt;subUserList.stream()).map(user -&gt; dao2Dto(user)).collect(Collectors.toList());&#125; flatMapToInt用法参考 flatMap，将元素扁平为 int 类型，在 flatMap方法的基础上进行封装。 flatMapToLong用法参考 flatMap，将元素扁平为 Long 类型，在 flatMap方法的基础上进行封装。 flatMapToDouble用法参考 flatMap，将元素扁平为 Double 类型，在 flatMap方法的基础上进行封装。 collection在进行了一系列操作之后，我们最终的结果大多数时候并不是为了获取 Stream 类型的数据，而是要把结果变为 List、Map 这样的常用数据结构，而 collection就是为了实现这个目的。 就拿 map 方法的那个例子说明，将对象类型进行转换后，最终我们需要的结果集是一个 List&lt;UserDto &gt;类型的，使用 collect方法将 Stream 转换为我们需要的类型。 下面是 collect接口方法的定义： 1&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 下面这个例子演示了将一个简单的 Integer Stream 过滤出大于 7 的值，然后转换成 List&lt;Integer&gt;集合，用的是 Collectors.toList()这个收集器。 1234private static void collect()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); List&lt;Integer&gt; list = integerStream.filter(s -&gt; s.intValue()&gt;7).collect(Collectors.toList());&#125; 很多同学表示看不太懂这个 Collector是怎么一个意思，来，我们看下面这段代码，这是 collect的另一个重载方法，你可以理解为它的参数是按顺序执行的，这样就清楚了，这就是个 ArrayList 从创建到调用 addAll方法的一个过程。 12345private static void collect()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); List&lt;Integer&gt; list = integerStream.filter(s -&gt; s.intValue()&gt;7).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);&#125; 我们在自定义 Collector的时候其实也是这个逻辑，不过我们根本不用自定义， Collectors已经为我们提供了很多拿来即用的收集器。比如我们经常用到Collectors.toList()、Collectors.toSet()、Collectors.toMap()。另外还有比如Collectors.groupingBy()用来分组，比如下面这个例子，按照 userId 字段分组，返回以 userId 为key，List 为value 的 Map，或者返回每个 key 的个数。 12345// 返回 userId:List&lt;User&gt;Map&lt;String,List&lt;User&gt;&gt; map = user.stream().collect(Collectors.groupingBy(User::getUserId));// 返回 userId:每组个数Map&lt;String,Long&gt; map = user.stream().collect(Collectors.groupingBy(User::getUserId,Collectors.counting())); toArraycollection是返回列表、map 等，toArray是返回数组，有两个重载，一个空参数，返回的是 Object[]。 另一个接收一个 IntFunction&lt;R&gt;类型参数。 1234567891011@FunctionalInterfacepublic interface IntFunction&lt;R&gt; &#123; /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ R apply(int value);&#125; 比如像下面这样使用，参数是 User[]::new也就是new 一个 User 数组，长度为最后的 Stream 长度。 12345private static void toArray() &#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); User[] userArray = stream.filter(user -&gt; user.getGender().equals(0) &amp;&amp; user.getAge() &gt; 50).toArray(User[]::new);&#125; reduce它的作用是每次计算的时候都用到上一次的计算结果，比如求和操作，前两个数的和加上第三个数的和，再加上第四个数，一直加到最后一个数位置，最后返回结果，就是 reduce的工作过程。 12345private static void reduce()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); Integer sum = integerStream.reduce(0,(x,y)-&gt;x+y); System.out.println(sum);&#125; 另外 Collectors好多方法都用到了 reduce，比如 groupingBy、minBy、maxBy等等。 并行 StreamStream 本质上来说就是用来做数据处理的，为了加快处理速度，Stream API 提供了并行处理 Stream 的方式。通过 users.parallelStream()或者users.stream().parallel() 的方式来创建并行 Stream 对象，支持的 API 和普通 Stream 几乎是一致的。","tags":[]},{"title":"SpringBoot整合Mybatis详细流程","date":"2022-01-04T10:38:05.000Z","path":"2022/01/04/SpringBoot整合Mybatis详细流程/","text":"基础环境准备1、数据库准备使用MySQL，创建数据库spring-boot-mybatis，然后在该数据库中创建两个表course和comment，并向表中插入一些基础数据。 12345678910111213141516171819202122232425262728293031323334353637# 创建数据库CREATE DATABASE spring-boot-mybatis; USE spring-boot-mybatis;# 创建表courseDROP TABLE IF EXISTS course; CREATE TABLE course (id int(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;课程id&#x27;, title varchar(200) DEFAULT NULL COMMENT &#x27;课程标题&#x27;,content longtext COMMENT &#x27;课程内容&#x27;,PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO course VALUES (&#x27;1&#x27;, &#x27;Spring Boot基础入门&#x27;, &#x27;从入门到精通讲解...&#x27;); INSERT INTO t_article VALUES (&#x27;2&#x27;, &#x27;Spring Cloud基础入门&#x27;, &#x27;从入门到精通讲解...&#x27;);# 创建表commentDROP TABLE IF EXISTS comment; CREATE TABLE comment (id int(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;评论id&#x27;, content longtext COMMENT &#x27;评论内容&#x27;,author varchar(200) DEFAULT NULL COMMENT &#x27;评论作者&#x27;, c_id int(20) DEFAULT NULL COMMENT &#x27;关联的课程id&#x27;, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;INSERT INTO t_comment VALUES (&#x27;1&#x27;, &#x27;很全、很详细&#x27;, &#x27;lucy&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;2&#x27;, &#x27;赞一个&#x27;, &#x27;tom&#x27;, &#x27;1&#x27;);INSERT INTO t_comment VALUES (&#x27;3&#x27;, &#x27;很详细&#x27;, &#x27;eric&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;4&#x27;, &#x27;很好，非常详细&#x27;, &#x27;张三&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;5&#x27;, &#x27;很不错&#x27;, &#x27;李四&#x27;, &#x27;2&#x27;); 2、创建对应的SpringBoot项目此处省略 3、编写与数据库对应的实体类(set和get方法省略）123456789101112public class Comment &#123; private Integer id; private String content; private String author; private Integer aId;&#125;public class Course &#123; private Integer id; private String title; private String content;&#125; 4、编写SpringBoot的配置文件123456# MySQL数据库连接配置 spring: datasource: url: jdbc:mysql://localhost:3306/springbootmybatis?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: root password: rootroot 配置文件整合Mybatis创建course数据库对应的操作接口CourseMapper123public interface CourseMapper &#123; public Article selectCourse(Integer id);&#125; 创建Mapper对应的XML映射文件resources目录下创建一个统一管理映射文件的包mapper，并在该包下编写与CourseMapper接口方应的映射文件CourseMapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.springboot.mapper.CourseMapper&quot;&gt; &lt;select id=&quot;selectCourse&quot; resultType=&quot;Course&quot;&gt; select * from course &lt;/select&gt;&lt;/mapper&gt; 配置XML映射文件路径在项目中编写的XML映射文件，SpringBoot并不知道，所以无法扫描到自定义编写的XML配置文 件，还必须在全局配置文件application.yml中添加MyBatis映射文件路径的配置，同时需要添加 实体类别名映射路径，示例代码如下 12345mybatis: #配置MyBatis的xml配置文件路径 mapper-locations: classpath:mapper/*.xml #配置XML映射文件中指定的实体类别名路径 type-aliases-package: com.mybatis.entity 编写单元测试进行接口方法测试12345678@Autowiredprivate CourseMapper courseMapper;@Testvoid springBootAndMybatisTest() &#123; Course course = courseMapper.selectCourse(1); System.out.println(course);&#125; 至此SpringBoot整合Mybatis流程已经完成。","tags":[]},{"title":"hutool工具类","date":"2021-12-27T10:06:40.000Z","path":"2021/12/27/hutool工具类/","text":"安装Hutool的安装非常简单，Maven项目中只需在pom.xml添加以下依赖即可。 12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.4.0&lt;/version&gt;&lt;/dependency&gt; 常用工具类 使用一个工具方法代替一段复杂代码，避免复制粘贴代码，可以极大的提高我们的开发效率 Convert类型转换工具类，用于各种类型数据的转换。平时我们转换类型经常会面临类型转换失败的问题，要写try catch代码，有了它，就不用写了！ 123456789101112//转换为字符串int a = 1;String aStr = Convert.toStr(a);//转换为指定类型数组String[] b = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;&#125;;Integer[] bArr = Convert.toIntArray(b);//转换为日期对象String dateStr = &quot;2017-05-06&quot;;Date date = Convert.toDate(dateStr);//转换为列表String[] strArr = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;;List&lt;String&gt; strList = Convert.toList(String.class, strArr); DateUtil日期时间工具类，定义了一些常用的日期时间操作方法。JDK自带的Date和Calendar对象真心不好用，有了它操作日期时间就简单多了！ 12345678910111213141516171819202122232425//Date、long、Calendar之间的相互转换//当前时间Date date = DateUtil.date();//Calendar转Datedate = DateUtil.date(Calendar.getInstance());//时间戳转Datedate = DateUtil.date(System.currentTimeMillis());//自动识别格式转换String dateStr = &quot;2017-03-01&quot;;date = DateUtil.parse(dateStr);//自定义格式化转换date = DateUtil.parse(dateStr, &quot;yyyy-MM-dd&quot;);//格式化输出日期String format = DateUtil.format(date, &quot;yyyy-MM-dd&quot;);//获得年的部分int year = DateUtil.year(date);//获得月份，从0开始计数int month = DateUtil.month(date);//获取某天的开始、结束时间Date beginOfDay = DateUtil.beginOfDay(date);Date endOfDay = DateUtil.endOfDay(date);//计算偏移后的日期时间Date newDate = DateUtil.offset(date, DateField.DAY_OF_MONTH, 2);//计算日期时间之间的偏移量long betweenDay = DateUtil.between(date, newDate, DateUnit.DAY); JSONUtilJSON解析工具类，可用于对象与JSON之间的互相转化。 12345678910111213141516PmsBrand brand = new PmsBrand();brand.setId(1L);brand.setName(&quot;小米&quot;);brand.setShowStatus(1);//对象转化为JSON字符串String jsonStr = JSONUtil.parse(brand).toString();LOGGER.info(&quot;jsonUtil parse:&#123;&#125;&quot;, jsonStr);//JSON字符串转化为对象PmsBrand brandBean = JSONUtil.toBean(jsonStr, PmsBrand.class);LOGGER.info(&quot;jsonUtil toBean:&#123;&#125;&quot;, brandBean);List&lt;PmsBrand&gt; brandList = new ArrayList&lt;&gt;();brandList.add(brand);String jsonListStr = JSONUtil.parse(brandList).toString();//JSON字符串转化为列表brandList = JSONUtil.toList(new JSONArray(jsonListStr), PmsBrand.class);LOGGER.info(&quot;jsonUtil toList:&#123;&#125;&quot;, brandList); StrUtil字符串工具类，定义了一些常用的字符串操作方法。StrUtil比StringUtil名称更短，用起来也更方便！ 1234567891011//判断是否为空字符串String str = &quot;test&quot;;StrUtil.isEmpty(str);StrUtil.isNotEmpty(str);//去除字符串的前后缀StrUtil.removeSuffix(&quot;a.jpg&quot;, &quot;.jpg&quot;);StrUtil.removePrefix(&quot;a.jpg&quot;, &quot;a.&quot;);//格式化字符串String template = &quot;这只是个占位符:&#123;&#125;&quot;;String str2 = StrUtil.format(template, &quot;我是占位符&quot;);LOGGER.info(&quot;/strUtil format:&#123;&#125;&quot;, str2); ClassPathResourceClassPath单一资源访问类，可以获取classPath下的文件，在Tomcat等容器下，classPath一般是WEB-INF/classes。 12345//获取定义在src/main/resources文件夹中的配置文件ClassPathResource resource = new ClassPathResource(&quot;generator.properties&quot;);Properties properties = new Properties();properties.load(resource.getStream());LOGGER.info(&quot;/classPath:&#123;&#125;&quot;, properties); ReflectUtilJava反射工具类，可用于反射获取类的方法及创建对象。 12345678//获取某个类的所有方法Method[] methods = ReflectUtil.getMethods(PmsBrand.class);//获取某个类的指定方法Method method = ReflectUtil.getMethod(PmsBrand.class, &quot;getId&quot;);//使用反射来创建对象PmsBrand pmsBrand = ReflectUtil.newInstance(PmsBrand.class);//反射执行对象的方法ReflectUtil.invoke(pmsBrand, &quot;setId&quot;, 1); NumberUtil数字处理工具类，可用于各种类型数字的加减乘除操作及类型判断。 123456789101112131415double n1 = 1.234;double n2 = 1.234;double result;//对float、double、BigDecimal做加减乘除操作result = NumberUtil.add(n1, n2);result = NumberUtil.sub(n1, n2);result = NumberUtil.mul(n1, n2);result = NumberUtil.div(n1, n2);//保留两位小数BigDecimal roundNum = NumberUtil.round(n1, 2);String n3 = &quot;1.234&quot;;//判断是否为数字、整数、浮点数NumberUtil.isNumber(n3);NumberUtil.isInteger(n3);NumberUtil.isDouble(n3); BeanUtilJavaBean工具类，可用于Map与JavaBean对象的互相转换以及对象属性的拷贝。 1234567891011121314PmsBrand brand = new PmsBrand();brand.setId(1L);brand.setName(&quot;小米&quot;);brand.setShowStatus(0);//Bean转MapMap&lt;String, Object&gt; map = BeanUtil.beanToMap(brand);LOGGER.info(&quot;beanUtil bean to map:&#123;&#125;&quot;, map);//Map转BeanPmsBrand mapBrand = BeanUtil.mapToBean(map, PmsBrand.class, false);LOGGER.info(&quot;beanUtil map to bean:&#123;&#125;&quot;, mapBrand);//Bean属性拷贝PmsBrand copyBrand = new PmsBrand();BeanUtil.copyProperties(brand, copyBrand);LOGGER.info(&quot;beanUtil copy properties:&#123;&#125;&quot;, copyBrand); CollUtil集合操作的工具类，定义了一些常用的集合操作。 123456789101112131415//数组转换为列表String[] array = new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;;List&lt;String&gt; list = CollUtil.newArrayList(array);//join：数组转字符串时添加连接符号String joinStr = CollUtil.join(list, &quot;,&quot;);LOGGER.info(&quot;collUtil join:&#123;&#125;&quot;, joinStr);//将以连接符号分隔的字符串再转换为列表List&lt;String&gt; splitList = StrUtil.split(joinStr, &#x27;,&#x27;);LOGGER.info(&quot;collUtil split:&#123;&#125;&quot;, splitList);//创建新的Map、Set、ListHashMap&lt;Object, Object&gt; newMap = CollUtil.newHashMap();HashSet&lt;Object&gt; newHashSet = CollUtil.newHashSet();ArrayList&lt;Object&gt; newList = CollUtil.newArrayList();//判断列表是否为空CollUtil.isEmpty(list); MapUtilMap操作工具类，可用于创建Map对象及判断Map是否为空。 123456789//将多个键值对加入到Map中Map&lt;Object, Object&gt; map = MapUtil.of(new String[][]&#123; &#123;&quot;key1&quot;, &quot;value1&quot;&#125;, &#123;&quot;key2&quot;, &quot;value2&quot;&#125;, &#123;&quot;key3&quot;, &quot;value3&quot;&#125;&#125;);//判断Map是否为空MapUtil.isEmpty(map);MapUtil.isNotEmpty(map); AnnotationUtil注解工具类，可用于获取注解与注解中指定的值。 123456789//获取指定类、方法、字段、构造器上的注解列表Annotation[] annotationList = AnnotationUtil.getAnnotations(HutoolController.class, false);LOGGER.info(&quot;annotationUtil annotations:&#123;&#125;&quot;, annotationList);//获取指定类型注解Api api = AnnotationUtil.getAnnotation(HutoolController.class, Api.class);LOGGER.info(&quot;annotationUtil api value:&#123;&#125;&quot;, api.description());//获取指定类型注解的值Object annotationValue = AnnotationUtil.getAnnotationValue(HutoolController.class, RequestMapping.class);复制代码 SecureUtil加密解密工具类，可用于MD5加密。 12345//MD5加密String str = &quot;123456&quot;;String md5Str = SecureUtil.md5(str);LOGGER.info(&quot;secureUtil md5:&#123;&#125;&quot;, md5Str);复制代码 CaptchaUtil验证码工具类，可用于生成图形验证码。 12345678910111213//生成验证码图片LineCaptcha lineCaptcha = CaptchaUtil.createLineCaptcha(200, 100);try &#123; request.getSession().setAttribute(&quot;CAPTCHA_KEY&quot;, lineCaptcha.getCode()); response.setContentType(&quot;image/png&quot;);//告诉浏览器输出内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);//禁止浏览器缓存 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); lineCaptcha.write(response.getOutputStream());&#125; catch (IOException e) &#123; e.printStackTrace();&#125;复制代码 Validator字段验证器，可以对不同格式的字符串进行验证，比如邮箱、手机号、IP等格式。 12345678910111213141516171819202122//判断是否为邮箱地址boolean result = Validator.isEmail(&quot;macro@qq.com&quot;);LOGGER.info(&quot;Validator isEmail:&#123;&#125;&quot;, result);//判断是否为手机号码result = Validator.isMobile(&quot;18911111111&quot;);LOGGER.info(&quot;Validator isMobile:&#123;&#125;&quot;, result);//判断是否为IPV4地址result = Validator.isIpv4(&quot;192.168.3.101&quot;);LOGGER.info(&quot;Validator isIpv4:&#123;&#125;&quot;, result);//判断是否为汉字result = Validator.isChinese(&quot;你好&quot;);LOGGER.info(&quot;Validator isChinese:&#123;&#125;&quot;, result);//判断是否为身份证号码（18位中国）result = Validator.isCitizenId(&quot;123456&quot;);LOGGER.info(&quot;Validator isCitizenId:&#123;&#125;&quot;, result);//判断是否为URLresult = Validator.isUrl(&quot;http://www.baidu.com&quot;);LOGGER.info(&quot;Validator isUrl:&#123;&#125;&quot;, result);//判断是否为生日result = Validator.isBirthday(&quot;2020-02-01&quot;);LOGGER.info(&quot;Validator isBirthday:&#123;&#125;&quot;, result);复制代码 DigestUtil摘要算法工具类，支持MD5、SHA-256、Bcrypt等算法。 123456789101112String password = &quot;123456&quot;;//计算MD5摘要值，并转为16进制字符串String result = DigestUtil.md5Hex(password);LOGGER.info(&quot;DigestUtil md5Hex:&#123;&#125;&quot;, result);//计算SHA-256摘要值，并转为16进制字符串result = DigestUtil.sha256Hex(password);LOGGER.info(&quot;DigestUtil sha256Hex:&#123;&#125;&quot;, result);//生成Bcrypt加密后的密文，并校验String hashPwd = DigestUtil.bcrypt(password);boolean check = DigestUtil.bcryptCheck(password,hashPwd);LOGGER.info(&quot;DigestUtil bcryptCheck:&#123;&#125;&quot;, check);复制代码 HttpUtilHttp请求工具类，可以发起GET/POST等请求。 12String response = HttpUtil.get(&quot;http://localhost:8080/hutool/covert&quot;);LOGGER.info(&quot;HttpUtil get:&#123;&#125;&quot;, response); hutool官网www.hutool.cn/","tags":[]},{"title":"Hello World","date":"2021-12-17T06:49:33.859Z","path":"2021/12/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]