[{"title":"Java8的新特性","date":"2022-01-10T10:33:06.000Z","path":"2022/01/10/Java8的新特性/","text":"Lambda 表达式 Lambda 表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。 在 Java 中，Lambda 表达式的格式是像下面这样 12345// 无参数，无返回值() -&gt; log.info(&quot;Lambda&quot;) // 有参数，有返回值(int a, int b) -&gt; &#123; a+b &#125; 其等价于 12345log.info(&quot;Lambda&quot;);private int plus(int a, int b)&#123; return a+b;&#125; Stream APIStream 是 Java 8 中集合数据处理的利器，很多本来复杂、需要写很多代码的方法，比如过滤、分组等操作，往往使用 Stream 就可以在一行代码搞定，当然也因为 Stream 都是链式操作，一行代码可能会调用好几个方法。 Collection接口提供了 stream()方法，让我们可以在一个集合方便的使用 Stream API 来进行各种操作。值得注意的是，我们执行的任何操作都不会对源集合造成影响，你可以同时在一个集合上提取出多个 stream 进行操作。 Stream 常用 API： of可接收一个泛型对象或可变成泛型集合，构造一个 Stream 对象。 123private static void createStream()&#123; Stream&lt;String&gt; stringStream = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#125; empty创建一个空的 Stream 对象。 concat连接两个 Stream ，不改变其中任何一个 Steam 对象，返回一个新的 Stream 对象。 12345private static void concatStream()&#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); Stream&lt;String&gt; b = Stream.of(&quot;d&quot;,&quot;e&quot;); Stream&lt;String&gt; c = Stream.concat(a,b);&#125; max一般用于求数字集合中的最大值，或者按实体中数字类型的属性比较，拥有最大值的那个实体。它接收一个 Comparator&lt;T&gt;，上面也举到这个例子了，它是一个函数式接口类型，专门用作定义两个对象之间的比较，例如下面这个方法使用了 Integer::compareTo这个方法引用。 12345private static void max()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(2, 2, 100, 5); Integer max = integerStream.max(Integer::compareTo).get(); System.out.println(max);&#125; 当然，我们也可以自己定制一个 Comparator，顺便复习一下 Lambda 表达式形式的方法引用。 123456private static void max()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(2, 2, 100, 5); Comparator&lt;Integer&gt; comparator = (x, y) -&gt; (x.intValue() &lt; y.intValue()) ? -1 : ((x.equals(y)) ? 0 : 1); Integer max = integerStream.max(comparator).get(); System.out.println(max);&#125; min与 max 用法一样，只不过是求最小值。 findFirst获取 Stream 中的第一个元素。 findAny获取 Stream 中的某个元素，如果是串行情况下，一般都会返回第一个元素，并行情况下就不一定了。 count返回元素个数。 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);long x = a.count(); peek建立一个通道，在这个通道中对 Stream 的每个元素执行对应的操作，对应 Consumer&lt;T&gt;的函数式接口，这是一个消费者函数式接口，顾名思义，它是用来消费 Stream 元素的，比如下面这个方法，把每个元素转换成对应的大写字母并输出。 1234private static void peek() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); List&lt;String&gt; list = a.peek(e-&gt;System.out.println(e.toUpperCase())).collect(Collectors.toList());&#125; forEach和 peek 方法类似，都接收一个消费者函数式接口，可以对每个元素进行对应的操作，但是和 peek 不同的是，forEach 执行之后，这个 Stream 就真的被消费掉了，之后这个 Stream 流就没有了，不可以再对它进行后续操作了，而 peek操作完之后，还是一个可操作的 Stream 对象。 正好借着这个说一下，我们在使用 Stream API 的时候，都是一串链式操作，这是因为很多方法，比如接下来要说到的 filter方法等，返回值还是这个 Stream 类型的，也就是被当前方法处理过的 Stream 对象，所以 Stream API 仍然可以使用。 1234private static void forEach() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.forEach(e-&gt;System.out.println(e.toUpperCase()));&#125; forEachOrdered功能与 forEach是一样的，不同的是，forEachOrdered是有顺序保证的，也就是对 Stream 中元素按插入时的顺序进行消费。为什么这么说呢，当开启并行的时候，forEach和 forEachOrdered的效果就不一样了。 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);a.parallel().forEach(e-&gt;System.out.println(e.toUpperCase())); 当使用上面的代码时，输出的结果可能是 B、A、C 或者 A、C、B或者A、B、C，而使用下面的代码，则每次都是 A、 B、C 12Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);a.parallel().forEachOrdered(e-&gt;System.out.println(e.toUpperCase())); limit获取前 n 条数据，类似于 MySQL 的limit，只不过只能接收一个参数，就是数据条数。 1234private static void limit() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.limit(2).forEach(e-&gt;System.out.println(e));&#125; 上述代码打印的结果是 a、b。 skip跳过前 n 条数据，例如下面代码，返回结果是 c。 1234private static void skip() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); a.skip(2).forEach(e-&gt;System.out.println(e));&#125; distinct元素去重，例如下面方法返回元素是 a、b、c，将重复的 b 只保留了一个。 1234private static void distinct() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;b&quot;); a.distinct().forEach(e-&gt;System.out.println(e));&#125; sorted有两个重载，一个无参数，另外一个有个 Comparator类型的参数。 无参类型的按照自然顺序进行排序，只适合比较单纯的元素，比如数字、字母等。 1234private static void sorted() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;c&quot;, &quot;b&quot;); a.sorted().forEach(e-&gt;System.out.println(e));&#125; 有参数的需要自定义排序规则，例如下面这个方法，按照第二个字母的大小顺序排序，最后输出的结果是 a1、b3、c6。 1234private static void sortedWithComparator() &#123; Stream&lt;String&gt; a = Stream.of(&quot;a1&quot;, &quot;c6&quot;, &quot;b3&quot;); a.sorted((x,y)-&gt;Integer.parseInt(x.substring(1))&gt;Integer.parseInt(y.substring(1))?1:-1).forEach(e-&gt;System.out.println(e));&#125; 为了更好的说明接下来的几个 API ，我模拟了几条项目中经常用到的类似数据，10条用户信息。 123456789101112131415private static List&lt;User&gt; getUserData() &#123; Random random = new Random(); List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(); user.setUserId(i); user.setUserName(String.format(&quot;古时的风筝 %s 号&quot;, i)); user.setAge(random.nextInt(100)); user.setGender(i % 2); user.setPhone(&quot;18812021111&quot;); user.setAddress(&quot;无&quot;); users.add(user); &#125; return users;&#125; filter用于条件筛选过滤，筛选出符合条件的数据。例如下面这个方法，筛选出性别为 0，年龄大于 50 的记录。 123456789101112131415private static void filter()&#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); stream.filter(user -&gt; user.getGender().equals(0) &amp;&amp; user.getAge()&gt;50).forEach(e-&gt;System.out.println(e)); /** *等同于下面这种形式 匿名内部类 */// stream.filter(new Predicate&lt;User&gt;() &#123;// @Override// public boolean test(User user) &#123;// return user.getGender().equals(0) &amp;&amp; user.getAge()&gt;50;// &#125;// &#125;).forEach(e-&gt;System.out.println(e));&#125; mapmap方法的接口方法声明如下，接受一个 Function函数式接口，把它翻译成映射最合适了，通过原始数据元素，映射出新的类型。 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 而 Function的声明是这样的，观察 apply方法，接受一个 T 型参数，返回一个 R 型参数。用于将一个类型转换成另外一个类型正合适，这也是 map的初衷所在，用于改变当前元素的类型，例如将 Integer 转为 String类型，将 DAO 实体类型，转换为 DTO 实例类型。 当然了，T 和 R 的类型也可以一样，这样的话，就和 peek方法没什么不同了。 1234567891011@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t);&#125; 例如下面这个方法，应该是业务系统的常用需求，将 User 转换为 API 输出的数据格式。 123456789101112private static void map()&#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); List&lt;UserDto&gt; userDtos = stream.map(user -&gt; dao2Dto(user)).collect(Collectors.toList());&#125;private static UserDto dao2Dto(User user)&#123; UserDto dto = new UserDto(); BeanUtils.copyProperties(user, dto); //其他额外处理 return dto;&#125; mapToInt将元素转换成 int 类型，在 map方法的基础上进行封装。 mapToLong将元素转换成 Long 类型，在 map方法的基础上进行封装。 mapToDouble将元素转换成 Double 类型，在 map方法的基础上进行封装。 flatMap这是用在一些比较特别的场景下，当你的 Stream 是以下这几种结构的时候，需要用到 flatMap方法，用于将原有二维结构扁平化。 Stream&lt;String[]&gt; Stream&lt;Set&lt;String&gt;&gt; Stream&lt;List&lt;String&gt;&gt; 以上这三类结构，通过 flatMap方法，可以将结果转化为 Stream&lt;String&gt;这种形式，方便之后的其他操作。 比如下面这个方法，将List&lt;List&lt;User&gt;&gt;扁平处理，然后再使用 map或其他方法进行操作。 123456789private static void flatMap()&#123; List&lt;User&gt; users = getUserData(); List&lt;User&gt; users1 = getUserData(); List&lt;List&lt;User&gt;&gt; userList = new ArrayList&lt;&gt;(); userList.add(users); userList.add(users1); Stream&lt;List&lt;User&gt;&gt; stream = userList.stream(); List&lt;UserDto&gt; userDtos = stream.flatMap(subUserList-&gt;subUserList.stream()).map(user -&gt; dao2Dto(user)).collect(Collectors.toList());&#125; flatMapToInt用法参考 flatMap，将元素扁平为 int 类型，在 flatMap方法的基础上进行封装。 flatMapToLong用法参考 flatMap，将元素扁平为 Long 类型，在 flatMap方法的基础上进行封装。 flatMapToDouble用法参考 flatMap，将元素扁平为 Double 类型，在 flatMap方法的基础上进行封装。 collection在进行了一系列操作之后，我们最终的结果大多数时候并不是为了获取 Stream 类型的数据，而是要把结果变为 List、Map 这样的常用数据结构，而 collection就是为了实现这个目的。 就拿 map 方法的那个例子说明，将对象类型进行转换后，最终我们需要的结果集是一个 List&lt;UserDto &gt;类型的，使用 collect方法将 Stream 转换为我们需要的类型。 下面是 collect接口方法的定义： 1&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 下面这个例子演示了将一个简单的 Integer Stream 过滤出大于 7 的值，然后转换成 List&lt;Integer&gt;集合，用的是 Collectors.toList()这个收集器。 1234private static void collect()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); List&lt;Integer&gt; list = integerStream.filter(s -&gt; s.intValue()&gt;7).collect(Collectors.toList());&#125; 很多同学表示看不太懂这个 Collector是怎么一个意思，来，我们看下面这段代码，这是 collect的另一个重载方法，你可以理解为它的参数是按顺序执行的，这样就清楚了，这就是个 ArrayList 从创建到调用 addAll方法的一个过程。 12345private static void collect()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); List&lt;Integer&gt; list = integerStream.filter(s -&gt; s.intValue()&gt;7).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);&#125; 我们在自定义 Collector的时候其实也是这个逻辑，不过我们根本不用自定义， Collectors已经为我们提供了很多拿来即用的收集器。比如我们经常用到Collectors.toList()、Collectors.toSet()、Collectors.toMap()。另外还有比如Collectors.groupingBy()用来分组，比如下面这个例子，按照 userId 字段分组，返回以 userId 为key，List 为value 的 Map，或者返回每个 key 的个数。 12345// 返回 userId:List&lt;User&gt;Map&lt;String,List&lt;User&gt;&gt; map = user.stream().collect(Collectors.groupingBy(User::getUserId));// 返回 userId:每组个数Map&lt;String,Long&gt; map = user.stream().collect(Collectors.groupingBy(User::getUserId,Collectors.counting())); toArraycollection是返回列表、map 等，toArray是返回数组，有两个重载，一个空参数，返回的是 Object[]。 另一个接收一个 IntFunction&lt;R&gt;类型参数。 1234567891011@FunctionalInterfacepublic interface IntFunction&lt;R&gt; &#123; /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ R apply(int value);&#125; 比如像下面这样使用，参数是 User[]::new也就是new 一个 User 数组，长度为最后的 Stream 长度。 12345private static void toArray() &#123; List&lt;User&gt; users = getUserData(); Stream&lt;User&gt; stream = users.stream(); User[] userArray = stream.filter(user -&gt; user.getGender().equals(0) &amp;&amp; user.getAge() &gt; 50).toArray(User[]::new);&#125; reduce它的作用是每次计算的时候都用到上一次的计算结果，比如求和操作，前两个数的和加上第三个数的和，再加上第四个数，一直加到最后一个数位置，最后返回结果，就是 reduce的工作过程。 12345private static void reduce()&#123; Stream&lt;Integer&gt; integerStream = Stream.of(1,2,5,7,8,12,33); Integer sum = integerStream.reduce(0,(x,y)-&gt;x+y); System.out.println(sum);&#125; 另外 Collectors好多方法都用到了 reduce，比如 groupingBy、minBy、maxBy等等。 并行 StreamStream 本质上来说就是用来做数据处理的，为了加快处理速度，Stream API 提供了并行处理 Stream 的方式。通过 users.parallelStream()或者users.stream().parallel() 的方式来创建并行 Stream 对象，支持的 API 和普通 Stream 几乎是一致的。","tags":[]},{"title":"SpringBoot整合Mybatis详细流程","date":"2022-01-04T10:38:05.000Z","path":"2022/01/04/SpringBoot整合Mybatis详细流程/","text":"基础环境准备1、数据库准备使用MySQL，创建数据库spring-boot-mybatis，然后在该数据库中创建两个表course和comment，并向表中插入一些基础数据。 12345678910111213141516171819202122232425262728293031323334353637# 创建数据库CREATE DATABASE spring-boot-mybatis; USE spring-boot-mybatis;# 创建表courseDROP TABLE IF EXISTS course; CREATE TABLE course (id int(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;课程id&#x27;, title varchar(200) DEFAULT NULL COMMENT &#x27;课程标题&#x27;,content longtext COMMENT &#x27;课程内容&#x27;,PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO course VALUES (&#x27;1&#x27;, &#x27;Spring Boot基础入门&#x27;, &#x27;从入门到精通讲解...&#x27;); INSERT INTO t_article VALUES (&#x27;2&#x27;, &#x27;Spring Cloud基础入门&#x27;, &#x27;从入门到精通讲解...&#x27;);# 创建表commentDROP TABLE IF EXISTS comment; CREATE TABLE comment (id int(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;评论id&#x27;, content longtext COMMENT &#x27;评论内容&#x27;,author varchar(200) DEFAULT NULL COMMENT &#x27;评论作者&#x27;, c_id int(20) DEFAULT NULL COMMENT &#x27;关联的课程id&#x27;, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;INSERT INTO t_comment VALUES (&#x27;1&#x27;, &#x27;很全、很详细&#x27;, &#x27;lucy&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;2&#x27;, &#x27;赞一个&#x27;, &#x27;tom&#x27;, &#x27;1&#x27;);INSERT INTO t_comment VALUES (&#x27;3&#x27;, &#x27;很详细&#x27;, &#x27;eric&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;4&#x27;, &#x27;很好，非常详细&#x27;, &#x27;张三&#x27;, &#x27;1&#x27;); INSERT INTO t_comment VALUES (&#x27;5&#x27;, &#x27;很不错&#x27;, &#x27;李四&#x27;, &#x27;2&#x27;); 2、创建对应的SpringBoot项目此处省略 3、编写与数据库对应的实体类(set和get方法省略）123456789101112public class Comment &#123; private Integer id; private String content; private String author; private Integer aId;&#125;public class Course &#123; private Integer id; private String title; private String content;&#125; 4、编写SpringBoot的配置文件123456# MySQL数据库连接配置 spring: datasource: url: jdbc:mysql://localhost:3306/springbootmybatis?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: root password: rootroot 配置文件整合Mybatis创建course数据库对应的操作接口CourseMapper123public interface CourseMapper &#123; public Article selectCourse(Integer id);&#125; 创建Mapper对应的XML映射文件resources目录下创建一个统一管理映射文件的包mapper，并在该包下编写与CourseMapper接口方应的映射文件CourseMapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.springboot.mapper.CourseMapper&quot;&gt; &lt;select id=&quot;selectCourse&quot; resultType=&quot;Course&quot;&gt; select * from course &lt;/select&gt;&lt;/mapper&gt; 配置XML映射文件路径在项目中编写的XML映射文件，SpringBoot并不知道，所以无法扫描到自定义编写的XML配置文 件，还必须在全局配置文件application.yml中添加MyBatis映射文件路径的配置，同时需要添加 实体类别名映射路径，示例代码如下 12345mybatis: #配置MyBatis的xml配置文件路径 mapper-locations: classpath:mapper/*.xml #配置XML映射文件中指定的实体类别名路径 type-aliases-package: com.mybatis.entity 编写单元测试进行接口方法测试12345678@Autowiredprivate CourseMapper courseMapper;@Testvoid springBootAndMybatisTest() &#123; Course course = courseMapper.selectCourse(1); System.out.println(course);&#125; 至此SpringBoot整合Mybatis流程已经完成。","tags":[]},{"title":"hutool工具类","date":"2021-12-27T10:06:40.000Z","path":"2021/12/27/hutool工具类/","text":"安装Hutool的安装非常简单，Maven项目中只需在pom.xml添加以下依赖即可。 12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.4.0&lt;/version&gt;&lt;/dependency&gt; 常用工具类 使用一个工具方法代替一段复杂代码，避免复制粘贴代码，可以极大的提高我们的开发效率 Convert类型转换工具类，用于各种类型数据的转换。平时我们转换类型经常会面临类型转换失败的问题，要写try catch代码，有了它，就不用写了！ 123456789101112//转换为字符串int a = 1;String aStr = Convert.toStr(a);//转换为指定类型数组String[] b = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;&#125;;Integer[] bArr = Convert.toIntArray(b);//转换为日期对象String dateStr = &quot;2017-05-06&quot;;Date date = Convert.toDate(dateStr);//转换为列表String[] strArr = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;;List&lt;String&gt; strList = Convert.toList(String.class, strArr); DateUtil日期时间工具类，定义了一些常用的日期时间操作方法。JDK自带的Date和Calendar对象真心不好用，有了它操作日期时间就简单多了！ 12345678910111213141516171819202122232425//Date、long、Calendar之间的相互转换//当前时间Date date = DateUtil.date();//Calendar转Datedate = DateUtil.date(Calendar.getInstance());//时间戳转Datedate = DateUtil.date(System.currentTimeMillis());//自动识别格式转换String dateStr = &quot;2017-03-01&quot;;date = DateUtil.parse(dateStr);//自定义格式化转换date = DateUtil.parse(dateStr, &quot;yyyy-MM-dd&quot;);//格式化输出日期String format = DateUtil.format(date, &quot;yyyy-MM-dd&quot;);//获得年的部分int year = DateUtil.year(date);//获得月份，从0开始计数int month = DateUtil.month(date);//获取某天的开始、结束时间Date beginOfDay = DateUtil.beginOfDay(date);Date endOfDay = DateUtil.endOfDay(date);//计算偏移后的日期时间Date newDate = DateUtil.offset(date, DateField.DAY_OF_MONTH, 2);//计算日期时间之间的偏移量long betweenDay = DateUtil.between(date, newDate, DateUnit.DAY); JSONUtilJSON解析工具类，可用于对象与JSON之间的互相转化。 12345678910111213141516PmsBrand brand = new PmsBrand();brand.setId(1L);brand.setName(&quot;小米&quot;);brand.setShowStatus(1);//对象转化为JSON字符串String jsonStr = JSONUtil.parse(brand).toString();LOGGER.info(&quot;jsonUtil parse:&#123;&#125;&quot;, jsonStr);//JSON字符串转化为对象PmsBrand brandBean = JSONUtil.toBean(jsonStr, PmsBrand.class);LOGGER.info(&quot;jsonUtil toBean:&#123;&#125;&quot;, brandBean);List&lt;PmsBrand&gt; brandList = new ArrayList&lt;&gt;();brandList.add(brand);String jsonListStr = JSONUtil.parse(brandList).toString();//JSON字符串转化为列表brandList = JSONUtil.toList(new JSONArray(jsonListStr), PmsBrand.class);LOGGER.info(&quot;jsonUtil toList:&#123;&#125;&quot;, brandList); StrUtil字符串工具类，定义了一些常用的字符串操作方法。StrUtil比StringUtil名称更短，用起来也更方便！ 1234567891011//判断是否为空字符串String str = &quot;test&quot;;StrUtil.isEmpty(str);StrUtil.isNotEmpty(str);//去除字符串的前后缀StrUtil.removeSuffix(&quot;a.jpg&quot;, &quot;.jpg&quot;);StrUtil.removePrefix(&quot;a.jpg&quot;, &quot;a.&quot;);//格式化字符串String template = &quot;这只是个占位符:&#123;&#125;&quot;;String str2 = StrUtil.format(template, &quot;我是占位符&quot;);LOGGER.info(&quot;/strUtil format:&#123;&#125;&quot;, str2); ClassPathResourceClassPath单一资源访问类，可以获取classPath下的文件，在Tomcat等容器下，classPath一般是WEB-INF/classes。 12345//获取定义在src/main/resources文件夹中的配置文件ClassPathResource resource = new ClassPathResource(&quot;generator.properties&quot;);Properties properties = new Properties();properties.load(resource.getStream());LOGGER.info(&quot;/classPath:&#123;&#125;&quot;, properties); ReflectUtilJava反射工具类，可用于反射获取类的方法及创建对象。 12345678//获取某个类的所有方法Method[] methods = ReflectUtil.getMethods(PmsBrand.class);//获取某个类的指定方法Method method = ReflectUtil.getMethod(PmsBrand.class, &quot;getId&quot;);//使用反射来创建对象PmsBrand pmsBrand = ReflectUtil.newInstance(PmsBrand.class);//反射执行对象的方法ReflectUtil.invoke(pmsBrand, &quot;setId&quot;, 1); NumberUtil数字处理工具类，可用于各种类型数字的加减乘除操作及类型判断。 123456789101112131415double n1 = 1.234;double n2 = 1.234;double result;//对float、double、BigDecimal做加减乘除操作result = NumberUtil.add(n1, n2);result = NumberUtil.sub(n1, n2);result = NumberUtil.mul(n1, n2);result = NumberUtil.div(n1, n2);//保留两位小数BigDecimal roundNum = NumberUtil.round(n1, 2);String n3 = &quot;1.234&quot;;//判断是否为数字、整数、浮点数NumberUtil.isNumber(n3);NumberUtil.isInteger(n3);NumberUtil.isDouble(n3); BeanUtilJavaBean工具类，可用于Map与JavaBean对象的互相转换以及对象属性的拷贝。 1234567891011121314PmsBrand brand = new PmsBrand();brand.setId(1L);brand.setName(&quot;小米&quot;);brand.setShowStatus(0);//Bean转MapMap&lt;String, Object&gt; map = BeanUtil.beanToMap(brand);LOGGER.info(&quot;beanUtil bean to map:&#123;&#125;&quot;, map);//Map转BeanPmsBrand mapBrand = BeanUtil.mapToBean(map, PmsBrand.class, false);LOGGER.info(&quot;beanUtil map to bean:&#123;&#125;&quot;, mapBrand);//Bean属性拷贝PmsBrand copyBrand = new PmsBrand();BeanUtil.copyProperties(brand, copyBrand);LOGGER.info(&quot;beanUtil copy properties:&#123;&#125;&quot;, copyBrand); CollUtil集合操作的工具类，定义了一些常用的集合操作。 123456789101112131415//数组转换为列表String[] array = new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;;List&lt;String&gt; list = CollUtil.newArrayList(array);//join：数组转字符串时添加连接符号String joinStr = CollUtil.join(list, &quot;,&quot;);LOGGER.info(&quot;collUtil join:&#123;&#125;&quot;, joinStr);//将以连接符号分隔的字符串再转换为列表List&lt;String&gt; splitList = StrUtil.split(joinStr, &#x27;,&#x27;);LOGGER.info(&quot;collUtil split:&#123;&#125;&quot;, splitList);//创建新的Map、Set、ListHashMap&lt;Object, Object&gt; newMap = CollUtil.newHashMap();HashSet&lt;Object&gt; newHashSet = CollUtil.newHashSet();ArrayList&lt;Object&gt; newList = CollUtil.newArrayList();//判断列表是否为空CollUtil.isEmpty(list); MapUtilMap操作工具类，可用于创建Map对象及判断Map是否为空。 123456789//将多个键值对加入到Map中Map&lt;Object, Object&gt; map = MapUtil.of(new String[][]&#123; &#123;&quot;key1&quot;, &quot;value1&quot;&#125;, &#123;&quot;key2&quot;, &quot;value2&quot;&#125;, &#123;&quot;key3&quot;, &quot;value3&quot;&#125;&#125;);//判断Map是否为空MapUtil.isEmpty(map);MapUtil.isNotEmpty(map); AnnotationUtil注解工具类，可用于获取注解与注解中指定的值。 123456789//获取指定类、方法、字段、构造器上的注解列表Annotation[] annotationList = AnnotationUtil.getAnnotations(HutoolController.class, false);LOGGER.info(&quot;annotationUtil annotations:&#123;&#125;&quot;, annotationList);//获取指定类型注解Api api = AnnotationUtil.getAnnotation(HutoolController.class, Api.class);LOGGER.info(&quot;annotationUtil api value:&#123;&#125;&quot;, api.description());//获取指定类型注解的值Object annotationValue = AnnotationUtil.getAnnotationValue(HutoolController.class, RequestMapping.class);复制代码 SecureUtil加密解密工具类，可用于MD5加密。 12345//MD5加密String str = &quot;123456&quot;;String md5Str = SecureUtil.md5(str);LOGGER.info(&quot;secureUtil md5:&#123;&#125;&quot;, md5Str);复制代码 CaptchaUtil验证码工具类，可用于生成图形验证码。 12345678910111213//生成验证码图片LineCaptcha lineCaptcha = CaptchaUtil.createLineCaptcha(200, 100);try &#123; request.getSession().setAttribute(&quot;CAPTCHA_KEY&quot;, lineCaptcha.getCode()); response.setContentType(&quot;image/png&quot;);//告诉浏览器输出内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);//禁止浏览器缓存 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); lineCaptcha.write(response.getOutputStream());&#125; catch (IOException e) &#123; e.printStackTrace();&#125;复制代码 Validator字段验证器，可以对不同格式的字符串进行验证，比如邮箱、手机号、IP等格式。 12345678910111213141516171819202122//判断是否为邮箱地址boolean result = Validator.isEmail(&quot;macro@qq.com&quot;);LOGGER.info(&quot;Validator isEmail:&#123;&#125;&quot;, result);//判断是否为手机号码result = Validator.isMobile(&quot;18911111111&quot;);LOGGER.info(&quot;Validator isMobile:&#123;&#125;&quot;, result);//判断是否为IPV4地址result = Validator.isIpv4(&quot;192.168.3.101&quot;);LOGGER.info(&quot;Validator isIpv4:&#123;&#125;&quot;, result);//判断是否为汉字result = Validator.isChinese(&quot;你好&quot;);LOGGER.info(&quot;Validator isChinese:&#123;&#125;&quot;, result);//判断是否为身份证号码（18位中国）result = Validator.isCitizenId(&quot;123456&quot;);LOGGER.info(&quot;Validator isCitizenId:&#123;&#125;&quot;, result);//判断是否为URLresult = Validator.isUrl(&quot;http://www.baidu.com&quot;);LOGGER.info(&quot;Validator isUrl:&#123;&#125;&quot;, result);//判断是否为生日result = Validator.isBirthday(&quot;2020-02-01&quot;);LOGGER.info(&quot;Validator isBirthday:&#123;&#125;&quot;, result);复制代码 DigestUtil摘要算法工具类，支持MD5、SHA-256、Bcrypt等算法。 123456789101112String password = &quot;123456&quot;;//计算MD5摘要值，并转为16进制字符串String result = DigestUtil.md5Hex(password);LOGGER.info(&quot;DigestUtil md5Hex:&#123;&#125;&quot;, result);//计算SHA-256摘要值，并转为16进制字符串result = DigestUtil.sha256Hex(password);LOGGER.info(&quot;DigestUtil sha256Hex:&#123;&#125;&quot;, result);//生成Bcrypt加密后的密文，并校验String hashPwd = DigestUtil.bcrypt(password);boolean check = DigestUtil.bcryptCheck(password,hashPwd);LOGGER.info(&quot;DigestUtil bcryptCheck:&#123;&#125;&quot;, check);复制代码 HttpUtilHttp请求工具类，可以发起GET/POST等请求。 12String response = HttpUtil.get(&quot;http://localhost:8080/hutool/covert&quot;);LOGGER.info(&quot;HttpUtil get:&#123;&#125;&quot;, response); hutool官网www.hutool.cn/","tags":[]},{"title":"Hello World","date":"2021-12-17T06:49:33.859Z","path":"2021/12/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]